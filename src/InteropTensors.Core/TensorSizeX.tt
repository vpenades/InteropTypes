<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace InteropTensors
{
    <#
    
    var TDIM_MAX = 8;
    
    for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT)    
    {
        var TTENSORSIZE = $"TensorSize{TDIMCOUNT}";
        var TTENSORINDEX = $"TensorIndices{TDIMCOUNT}";

        var TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int d{idx}")); 
        var TNAMELESSTUPLE = (TDIMCOUNT>1?"(":"") + String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int")) + (TDIMCOUNT>1?")":""); 
        var TNAMEDTUPLE = (TDIMCOUNT>1?"(":"") + String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int  d{idx}")) + (TDIMCOUNT>1?")":"");        

    #>

    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct <#= TTENSORSIZE#>
        : IReadOnlyList<int>
        , IEquatable<<#= TTENSORSIZE#>>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public <#= TTENSORSIZE#> VerifyDimensions(<#= TARGS#>)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> if (Dim<#= TDIM#> != d<#= TDIM#>) throw new ArgumentException($"Dimension[<#= TDIM#>] mismatch; expect {d<#= TDIM#>}, but found {Dim<#= TDIM#>}");
            <# } #>

            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator <#= TTENSORSIZE#>(ReadOnlySpan<int> dims)
        {
            return new <#= TTENSORSIZE#>(dims);
        }

        public <#= TTENSORSIZE#>(<#= TARGS#>)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Dim<#= TDIM#> = d<#= TDIM#>;
            <# } #>

        }

        public <#= TTENSORSIZE#>(ReadOnlySpan<int> dims)
        {
            if (dims.Length != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(dims));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Dim<#= TDIM#> = dims[<#= TDIM#>];
            <# } #>

        }

        public <#= TTENSORSIZE#>(IReadOnlyList<int> dims)
        {
            if (dims.Count != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(dims));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Dim<#= TDIM#> = dims[<#= TDIM#>];
            <# } #>

        }

        <# if (TDIMCOUNT > 1) { #>

        public <#= TTENSORSIZE#>(in TensorSize<#= TDIMCOUNT-1#> head, int tail)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT-1; ++TDIM) { #> Dim<#= TDIM#> = head.Dim<#= TDIM#>;
            <# } #>

            Dim<#= TDIMCOUNT-1#> = tail;
        }

        <# } #>

        #endregion

        #region data

        <# if (TDIMCOUNT == 1) { #>

        <# } else { #>

        <#
        var TDECLX = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int idx{idx}"));
        var TNEGXX = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => "-1"));
        #>
public static readonly (<#= TDECLX#>) Invalid = (<#= TNEGXX#>);

        <# } #>

        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> public readonly int Dim<#= TDIM#>;
        <# } #>

        public override int GetHashCode()
        {
            int h=0;

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> h ^= Dim<#= TDIM#>.GetHashCode(); h *=17;
            <# } #>
            
            return h;
        }

        public static bool AreEqual(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> if (a.Dim<#= TDIM#> != b.Dim<#= TDIM#>) return false;
            <# } #>

            return true;
        }        

        public static bool operator ==(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b) { return AreEqual(a,b); }

        public static bool operator !=(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b) { return !AreEqual(a,b); }

        public bool Equals(<#= TTENSORSIZE#> other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is <#= TTENSORSIZE#> other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim<#= TDIMCOUNT-1#>;

        <# for(var TDIM = 1; TDIM < TDIMCOUNT; ++TDIM)
        { var TITEMSX = String.Join(", ",Enumerable.Range(0,TDIM).Select(idx => $"Dim{idx}")); #>
[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize<#= TDIM#> Head<#= TDIM#> => new TensorSize<#= TDIM#>(<#= TITEMSX#>);
        <# } #>

        <# for(var TDIM = 1; TDIM < TDIMCOUNT; ++TDIM)
        { var TITEMSX = String.Join(", ",Enumerable.Range(TDIMCOUNT-TDIM,TDIM).Select(idx => $"Dim{idx}")); #>
[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize<#= TDIM#> Tail<#= TDIM#> => new TensorSize<#= TDIM#>(<#= TITEMSX#>);
        <# } #>

        <# var TSTEPLEN = String.Join(" * ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Dim{idx}")); #>

        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => <#= TSTEPLEN#>;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => <#= TDIMCOUNT#>;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
        case <#= TDIM#>: return Dim<#= TDIM#>;
            <# } #>                    
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
    yield return Dim<#= TDIM#>;
        <# } #>
}

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { <# var TITEMS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Dim{idx}")); #>return new int[] { <#= TITEMS#> }; }

        #endregion

        #region API

        public static <#= TTENSORSIZE#> operator +(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Dim<#= TDIM#> + b.Dim<#= TDIM#> <# } #>);            
        }     

        public static <#= TTENSORSIZE#> operator -(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Dim<#= TDIM#> - b.Dim<#= TDIM#> <# } #>);            
        }  

        public static <#= TTENSORSIZE#> operator +(in <#= TTENSORSIZE#> a, in <#= TTENSORINDEX#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Dim<#= TDIM#> + b.Index<#= TDIM#> <# } #>);            
        }     

        public static <#= TTENSORSIZE#> operator -(in <#= TTENSORSIZE#> a, in <#= TTENSORINDEX#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Dim<#= TDIM#> - b.Index<#= TDIM#> <# } #>);            
        }  

        public static <#= TTENSORSIZE#> Min(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> Math.Min(a.Dim<#= TDIM#> , b.Dim<#= TDIM#>) <# } #>);            
        }     

        public static <#= TTENSORSIZE#> Max(in <#= TTENSORSIZE#> a, in <#= TTENSORSIZE#> b)        
        {
            return new <#= TTENSORSIZE#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> Math.Max(a.Dim<#= TDIM#> , b.Dim<#= TDIM#>) <# } #>);            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static <#= TTENSORSIZE#> ExclusiveUnion(<#= TTENSORSIZE#> srcSize, ref <#= TTENSORINDEX#> srcOffset, <#= TTENSORSIZE#> dstSize, ref <#= TTENSORINDEX#> dstOffset)
        {
            var s = <#= TTENSORSIZE#>.Min(srcSize, dstSize);

            s += <#= TTENSORINDEX#>.Min(default, srcOffset);
            srcOffset = <#= TTENSORINDEX#>.Max(default, srcOffset);

            s += <#= TTENSORINDEX#>.Min(default, dstOffset);
            dstOffset = <#= TTENSORINDEX#>.Max(default, dstOffset);
            
            srcSize = <#= TTENSORSIZE#>.Max(default, srcSize - srcOffset);
            dstSize = <#= TTENSORSIZE#>.Max(default, dstSize - dstOffset);

            s = <#= TTENSORSIZE#>.Min(srcSize, s);
            s = <#= TTENSORSIZE#>.Min(dstSize, s);
            s = <#= TTENSORSIZE#>.Max(default, s);

            return s;
        }


        <# if (TDIMCOUNT > 1) { #>        
        

        public TensorSize<#= TDIMCOUNT-1#> GetTensorHead()
        {
            return Head<#= TDIMCOUNT-1#>;
        }         

        <#}#>

        <# for(var TDIM = 1; TDIM < TDIMCOUNT; ++TDIM) { TARGS = String.Join(", ",Enumerable.Range(0,TDIM).Select(idx => $"int idx{idx}")); #>
public (TensorSize<#= TDIMCOUNT-TDIM#> dims, int offs) GetTensorTail(<#= TARGS#>)
        {
            <# for(var XDIM = 0; XDIM < TDIM; ++XDIM) { #>
if (idx<#= XDIM#> < 0 || idx<#= XDIM#> >= Dim<#= XDIM#>) throw new IndexOutOfRangeException(nameof(idx<#= XDIM#>));
            <# } #>            

            int idx = 0;
            int len = 1;

            <# for(var XDIM = TDIMCOUNT-1; XDIM > 0; --XDIM){ #>
<# if (XDIM < TDIM) { #>idx += idx<#= XDIM#> * len;  <# } #>len *= Dim<#= XDIM#>;
            <#}#>            
            idx += idx0 * len;            
            
            return (Tail<#= TDIMCOUNT-TDIM#>, idx);
        }

        <# } #>

        <# if (TDIMCOUNT == 1) { #>

        int GetItemIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        public int DecomposeIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        <# } else { #>



        <# TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int idx{idx}")); #>
public int GetFlattenedIndex(<#= TARGS#>)
        {
            <# for(var XDIM = 0; XDIM < TDIMCOUNT; ++XDIM) { #>
if (idx<#= XDIM#> < 0 || idx<#= XDIM#> >= Dim<#= XDIM#>) throw new IndexOutOfRangeException(nameof(idx<#= XDIM#>));
            <# } #>            

            int idx = 0;
            int len = 1;

            <# for(var XDIM = TDIMCOUNT-1; XDIM > 0; --XDIM){ #>
idx += idx<#= XDIM#> * len; len *= Dim<#= XDIM#>;
            <#}#>
idx += idx0 * len;
            
            return idx;
        }
        
        <# var TRESULTIN = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"idx{idx}")); #>
/// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices<#= TDIMCOUNT#> GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

<# for(var XDIM = TDIMCOUNT-1; XDIM >= 0; --XDIM){ #>
            flattenedIndex = Math.DivRem(flattenedIndex, Dim<#= XDIM#>, out int idx<#= XDIM#>);
<#}#>

            return new TensorIndices<#= TDIMCOUNT#>(<#= TRESULTIN#>);
        }

        <# } #>

        <# TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int idx{idx}")); #>
public bool ContainsIndices(<#= TARGS#>)
        {
            <# for(var XDIM = 0; XDIM < TDIMCOUNT; ++XDIM) { #>
if (idx<#= XDIM#> < 0 || idx<#= XDIM#> >= Dim<#= XDIM#>) return false;
            <# } #>

            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, <#= TTENSORSIZE#> left, <#= TTENSORSIZE#> right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    <# } #>

}
