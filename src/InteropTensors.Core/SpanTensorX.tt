<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Numerics.Tensors;
using System.Text;

namespace InteropTensors
{
    <# var TDIM_MAX = 8; #>

    <# for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT) { #>

    <# var TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int d{idx}")); #>
    <# var TNEWSIZE = $"new TensorSize{TDIMCOUNT}(" + String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")) + ")";  #>

    /// <summary>
    /// Represents a dense tensor of <#= TDIMCOUNT#> dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor<#= TDIMCOUNT#><T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor<#= TDIMCOUNT#><T> VerifyDimensions(<#= TARGS#>)
        {
            <# var TVERIFYARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")); #>

            _Dimensions.VerifyDimensions(<#= TVERIFYARGS#>);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor<#= TDIMCOUNT#>(TensorSize<#= TDIMCOUNT#> dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor<#= TDIMCOUNT#>(<#= TARGS#>)
        {            
            _Dimensions = <#= TNEWSIZE#>;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor<#= TDIMCOUNT#>(Span<T> data, TensorSize<#= TDIMCOUNT#> dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor<#= TDIMCOUNT#>(Span<T> data, <#= TARGS#>)
        {
            _Dimensions = <#= TNEWSIZE#>;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor<#= TDIMCOUNT#>(IntPtr data, TensorSize<#= TDIMCOUNT#> dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor<#= TDIMCOUNT#>(IntPtr data, <#= TARGS#>)
        {
            _Dimensions = <#= TNEWSIZE#>;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor<#= TDIMCOUNT#>(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize<#= TDIMCOUNT#> _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize<#= TDIMCOUNT#> Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        <# if (TDIMCOUNT > 1) { #>

        public SpanTensor<#= TDIMCOUNT-1#><T> this[int idx] => GetSubTensor(idx);

        public T this[<#= TARGS#>]        
        {
            <# var TARGVARS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")); #>

            get => _Buffer[_Dimensions.GetFlattenedIndex(<#= TARGVARS#>)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(<#= TARGVARS#>)] = value;
        }

        <# } else { #>

        public T this[int idx] { get => _Buffer[idx]; set => _Buffer[idx] = value; }

        <# } #>

        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != <#= TDIMCOUNT#>) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        <# if (TDIMCOUNT > 1) { #>

        public void CopyTo(SpanTensor<#= TDIMCOUNT-1#><T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail<#= TDIMCOUNT-1#>) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor<#= TDIMCOUNT-1#><T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor<#= TDIMCOUNT-1#><T>(data,st.dims);
        }

        public unsafe SpanTensor<#= TDIMCOUNT-1#><TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor<#= TDIMCOUNT-1#><TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor<#= TDIMCOUNT#><T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor<#= TDIMCOUNT#><T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor<#= TDIMCOUNT#><T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        <# } #>

        <# if (TDIMCOUNT < TDIM_MAX-1) { #>

        public unsafe SpanTensor<#= TDIMCOUNT+1#><TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize<#= TDIMCOUNT+1#>(_Dimensions, last);

            return new SpanTensor<#= TDIMCOUNT+1#><TElement>(xdata, xdims);
        }        

        <# } #>

        <#
        for(var TDIMCOUNT2 = 1; TDIMCOUNT2 <= TDIM_MAX; ++TDIMCOUNT2)
            {
            var TARGS2 = String.Join(", ",Enumerable.Range(0,TDIMCOUNT2).Select(idx => $"int d{idx}"));
            var TVALS2 = String.Join(" * ",Enumerable.Range(0,TDIMCOUNT2).Select(idx => $"d{idx}"));
            var TNEWSIZE2 = $"new SpanTensor{TDIMCOUNT2}<T>(_Buffer, " + String.Join(", ",Enumerable.Range(0,TDIMCOUNT2).Select(idx => $"d{idx}")) + ")";
        #>

        public SpanTensor<#= TDIMCOUNT2#><T> Reshaped(<#= TARGS2#>)
        {
            if (_Buffer.Length != (<#= TVALS2#>)) throw new ArgumentException();
            return <#= TNEWSIZE2#>;
        }
        <#  } #>      
        

        #endregion
    }

    <# } #>

}
