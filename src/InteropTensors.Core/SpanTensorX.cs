// <auto-generated />
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Numerics.Tensors;
using System.Text;

namespace InteropTypes.Tensors
{
    
    
        
    /// <summary>
    /// Represents a dense tensor of 1 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor1<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor1<T> VerifyDimensions(int d0)
        {
            
            _Dimensions.VerifyDimensions(d0);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor1(TensorSize1 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor1(int d0)
        {            
            _Dimensions = new TensorSize1(d0);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor1(Span<T> data, TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor1(Span<T> data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor1(IntPtr data, TensorSize1 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor1(IntPtr data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor1(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize1 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize1 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public T this[int idx] { get => _Buffer[idx]; set => _Buffer[idx] = value; }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 1) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        
        public unsafe SpanTensor2<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize2(_Dimensions, last);

            return new SpanTensor2<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 2 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor2<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor2<T> VerifyDimensions(int d0, int d1)
        {
            
            _Dimensions.VerifyDimensions(d0, d1);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor2(TensorSize2 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor2(int d0, int d1)
        {            
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor2(Span<T> data, TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor2(Span<T> data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor2(IntPtr data, TensorSize2 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor2(IntPtr data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor2(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize2 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize2 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor1<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 2) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor1<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail1) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor1<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor1<T>(data,st.dims);
        }

        public unsafe SpanTensor2<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize2(_Dimensions.Head1, lastDim);            

            return new SpanTensor2<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor1<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor1<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor2<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        public unsafe SpanTensor3<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize3(_Dimensions, last);

            return new SpanTensor3<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 3 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor3<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor3<T> VerifyDimensions(int d0, int d1, int d2)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor3(TensorSize3 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor3(int d0, int d1, int d2)
        {            
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor3(Span<T> data, TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor3(Span<T> data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor3(IntPtr data, TensorSize3 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor3(IntPtr data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor3(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize3 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize3 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor2<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 3) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor2<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail2) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor2<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor2<T>(data,st.dims);
        }

        public unsafe SpanTensor3<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize3(_Dimensions.Head2, lastDim);            

            return new SpanTensor3<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor2<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor2<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor3<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        public unsafe SpanTensor4<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize4(_Dimensions, last);

            return new SpanTensor4<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 4 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor4<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor4<T> VerifyDimensions(int d0, int d1, int d2, int d3)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor4(TensorSize4 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor4(int d0, int d1, int d2, int d3)
        {            
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor4(Span<T> data, TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor4(Span<T> data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor4(IntPtr data, TensorSize4 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor4(IntPtr data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor4(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize4 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize4 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor3<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 4) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor3<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail3) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor3<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor3<T>(data,st.dims);
        }

        public unsafe SpanTensor4<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize4(_Dimensions.Head3, lastDim);            

            return new SpanTensor4<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor3<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor3<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor4<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        public unsafe SpanTensor5<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize5(_Dimensions, last);

            return new SpanTensor5<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 5 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor5<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor5<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor5(TensorSize5 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor5(int d0, int d1, int d2, int d3, int d4)
        {            
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor5(Span<T> data, TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor5(Span<T> data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor5(IntPtr data, TensorSize5 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor5(IntPtr data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor5(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize5 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize5 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor4<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 5) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor4<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail4) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor4<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor4<T>(data,st.dims);
        }

        public unsafe SpanTensor5<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize5(_Dimensions.Head4, lastDim);            

            return new SpanTensor5<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor4<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor4<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor5<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        public unsafe SpanTensor6<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize6(_Dimensions, last);

            return new SpanTensor6<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 6 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor6<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor6<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor6(TensorSize6 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor6(int d0, int d1, int d2, int d3, int d4, int d5)
        {            
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor6(Span<T> data, TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor6(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor6(IntPtr data, TensorSize6 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor6(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor6(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize6 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize6 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor5<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 6) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor5<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail5) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor5<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor5<T>(data,st.dims);
        }

        public unsafe SpanTensor6<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize6(_Dimensions.Head5, lastDim);            

            return new SpanTensor6<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor5<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor5<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor6<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        public unsafe SpanTensor7<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize7(_Dimensions, last);

            return new SpanTensor7<TElement>(xdata, xdims);
        }        

        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 7 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor7<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor7<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor7(TensorSize7 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor7(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {            
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor7(Span<T> data, TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor7(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor7(IntPtr data, TensorSize7 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor7(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor7(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize7 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize7 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor6<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 7) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor6<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail6) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor6<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor6<T>(data,st.dims);
        }

        public unsafe SpanTensor7<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize7(_Dimensions.Head6, lastDim);            

            return new SpanTensor7<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor6<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor6<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor7<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
        
    /// <summary>
    /// Represents a dense tensor of 8 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor8<T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }

        public SpanTensor8<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6, d7);
            return this;
        }

        #endregion

        #region lifecycle

        public SpanTensor8(TensorSize8 dims)
        {            
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor8(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {            
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor8(Span<T> data, TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor8(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }        

        public unsafe SpanTensor8(IntPtr data, TensorSize8 dims)
        {            
            _Dimensions = dims;            
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor8(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public SpanTensor8(DenseTensor<T> tensor)
        {
            _Dimensions = tensor.Dimensions;
            _Buffer = tensor.Buffer.Span;            
        }

        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize8 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public TensorSize8 Dimensions => _Dimensions;

        public Span<T> Span => _Buffer;

        public ReadOnlySpan<T> ReadOnlySpan => _Buffer;

        public T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor7<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7]        
        {
            
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6, d7)];
            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6, d7)] = value;
        }

        
        public Statistics Statistics => Statistics.Create(this.ReadOnlySpan);

        #endregion

        #region API

        public void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      

        public void CopyTo(ref DenseTensor<T> dst)
        {
            if (dst != null && dst.Dimensions.Length != 8) dst = null;
            // if dims don't match, dst = null

            if (dst == null) dst = new DenseTensor<T>(_Dimensions.ToArray());

            this._Buffer.CopyTo(dst.Buffer.Span);
        }        

        
        public void CopyTo(SpanTensor7<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail7) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public SpanTensor7<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor7<T>(data,st.dims);
        }

        public unsafe SpanTensor8<TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new TensorSize8(_Dimensions.Head7, lastDim);            

            return new SpanTensor8<TElement>(xdata, xdims);
        }

        public unsafe SpanTensor7<TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new SpanTensor7<TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public void CopyTransposed(SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public bool CopyTransposed(ref SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor8<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }
        
        public SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }
        
        public SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }
        
        public SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }
        
        public SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }
        
        public SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }
        
        public SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }
        
        public SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }
              
        

        #endregion
    }

    
}
