// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace InteropTensors
{
    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize1
        : IReadOnlyList<int>
        , IEquatable<TensorSize1>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize1 VerifyDimensions(int d0)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize1(ReadOnlySpan<int> dims)
        {
            return new TensorSize1(dims);
        }

        public TensorSize1(int d0)
        {
             Dim0 = d0;
            
        }

        public TensorSize1(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 1) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
            
        }

        public TensorSize1(IReadOnlyList<int> dims)
        {
            if (dims.Count != 1) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
            
        }

        
        #endregion

        #region data

        
        
         public readonly int Dim0;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize1 a, in TensorSize1 b)
        {
             if (a.Dim0 != b.Dim0) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize1 a, in TensorSize1 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize1 a, in TensorSize1 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize1 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize1 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim0;

        
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 1;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0 }; }

        #endregion

        #region API        

        
        
        
        int GetItemIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        public int DecomposeIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize2
        : IReadOnlyList<int>
        , IEquatable<TensorSize2>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize2 VerifyDimensions(int d0, int d1)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize2(ReadOnlySpan<int> dims)
        {
            return new TensorSize2(dims);
        }

        public TensorSize2(int d0, int d1)
        {
             Dim0 = d0;
             Dim1 = d1;
            
        }

        public TensorSize2(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 2) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
            
        }

        public TensorSize2(IReadOnlyList<int> dims)
        {
            if (dims.Count != 2) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
            
        }

        
        public TensorSize2(in TensorSize1 head, int tail)
        {
             Dim0 = head.Dim0;
            
            Dim1 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1) Invalid = (-1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize2 a, in TensorSize2 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize2 a, in TensorSize2 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize2 a, in TensorSize2 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize2 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize2 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim1;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim1);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 2;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1 }; }

        #endregion

        #region API        

                
        

        public TensorSize1 GetTensorHead()
        {
            return Head1;
        }         

        
        public (TensorSize1 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices2 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices2(idx0, idx1);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize3
        : IReadOnlyList<int>
        , IEquatable<TensorSize3>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize3 VerifyDimensions(int d0, int d1, int d2)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize3(ReadOnlySpan<int> dims)
        {
            return new TensorSize3(dims);
        }

        public TensorSize3(int d0, int d1, int d2)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
            
        }

        public TensorSize3(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 3) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
            
        }

        public TensorSize3(IReadOnlyList<int> dims)
        {
            if (dims.Count != 3) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
            
        }

        
        public TensorSize3(in TensorSize2 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
            
            Dim2 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2) Invalid = (-1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize3 a, in TensorSize3 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize3 a, in TensorSize3 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize3 a, in TensorSize3 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize3 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize3 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim2;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim1, Dim2);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 3;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2 }; }

        #endregion

        #region API        

                
        

        public TensorSize2 GetTensorHead()
        {
            return Head2;
        }         

        
        public (TensorSize2 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices3 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices3(idx0, idx1, idx2);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize4
        : IReadOnlyList<int>
        , IEquatable<TensorSize4>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize4 VerifyDimensions(int d0, int d1, int d2, int d3)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize4(ReadOnlySpan<int> dims)
        {
            return new TensorSize4(dims);
        }

        public TensorSize4(int d0, int d1, int d2, int d3)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
            
        }

        public TensorSize4(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 4) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
            
        }

        public TensorSize4(IReadOnlyList<int> dims)
        {
            if (dims.Count != 4) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
            
        }

        
        public TensorSize4(in TensorSize3 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
            
            Dim3 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3) Invalid = (-1, -1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
         public readonly int Dim3;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize4 a, in TensorSize4 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize4 a, in TensorSize4 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize4 a, in TensorSize4 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize4 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize4 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim3;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Tail3 => new TensorSize3(Dim1, Dim2, Dim3);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2 * Dim3;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 4;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3 }; }

        #endregion

        #region API        

                
        

        public TensorSize3 GetTensorHead()
        {
            return Head3;
        }         

        
        public (TensorSize3 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices4 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices4(idx0, idx1, idx2, idx3);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize5
        : IReadOnlyList<int>
        , IEquatable<TensorSize5>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize5 VerifyDimensions(int d0, int d1, int d2, int d3, int d4)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize5(ReadOnlySpan<int> dims)
        {
            return new TensorSize5(dims);
        }

        public TensorSize5(int d0, int d1, int d2, int d3, int d4)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
            
        }

        public TensorSize5(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 5) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
            
        }

        public TensorSize5(IReadOnlyList<int> dims)
        {
            if (dims.Count != 5) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
            
        }

        
        public TensorSize5(in TensorSize4 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
            
            Dim4 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4) Invalid = (-1, -1, -1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
         public readonly int Dim3;
         public readonly int Dim4;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize5 a, in TensorSize5 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize5 a, in TensorSize5 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize5 a, in TensorSize5 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize5 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize5 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim4;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Tail3 => new TensorSize3(Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Tail4 => new TensorSize4(Dim1, Dim2, Dim3, Dim4);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 5;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4 }; }

        #endregion

        #region API        

                
        

        public TensorSize4 GetTensorHead()
        {
            return Head4;
        }         

        
        public (TensorSize4 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices5 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices5(idx0, idx1, idx2, idx3, idx4);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize6
        : IReadOnlyList<int>
        , IEquatable<TensorSize6>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize6 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize6(ReadOnlySpan<int> dims)
        {
            return new TensorSize6(dims);
        }

        public TensorSize6(int d0, int d1, int d2, int d3, int d4, int d5)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
            
        }

        public TensorSize6(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 6) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
            
        }

        public TensorSize6(IReadOnlyList<int> dims)
        {
            if (dims.Count != 6) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
            
        }

        
        public TensorSize6(in TensorSize5 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
            
            Dim5 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5) Invalid = (-1, -1, -1, -1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
         public readonly int Dim3;
         public readonly int Dim4;
         public readonly int Dim5;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize6 a, in TensorSize6 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize6 a, in TensorSize6 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize6 a, in TensorSize6 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize6 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize6 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim5;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Tail3 => new TensorSize3(Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Tail4 => new TensorSize4(Dim2, Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Tail5 => new TensorSize5(Dim1, Dim2, Dim3, Dim4, Dim5);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 6;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5 }; }

        #endregion

        #region API        

                
        

        public TensorSize5 GetTensorHead()
        {
            return Head5;
        }         

        
        public (TensorSize5 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices6 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices6(idx0, idx1, idx2, idx3, idx4, idx5);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize7
        : IReadOnlyList<int>
        , IEquatable<TensorSize7>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize7 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
             if (Dim6 != d6) throw new ArgumentException($"Dimension[6] mismatch; expect {d6}, but found {Dim6}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize7(ReadOnlySpan<int> dims)
        {
            return new TensorSize7(dims);
        }

        public TensorSize7(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
             Dim6 = d6;
            
        }

        public TensorSize7(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 7) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
            
        }

        public TensorSize7(IReadOnlyList<int> dims)
        {
            if (dims.Count != 7) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
            
        }

        
        public TensorSize7(in TensorSize6 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
             Dim5 = head.Dim5;
            
            Dim6 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6) Invalid = (-1, -1, -1, -1, -1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
         public readonly int Dim3;
         public readonly int Dim4;
         public readonly int Dim5;
         public readonly int Dim6;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
             h ^= Dim6.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize7 a, in TensorSize7 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
             if (a.Dim6 != b.Dim6) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize7 a, in TensorSize7 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize7 a, in TensorSize7 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize7 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize7 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim6;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize6 Head6 => new TensorSize6(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Tail3 => new TensorSize3(Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Tail4 => new TensorSize4(Dim3, Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Tail5 => new TensorSize5(Dim2, Dim3, Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize6 Tail6 => new TensorSize6(Dim1, Dim2, Dim3, Dim4, Dim5, Dim6);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5 * Dim6;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 7;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                    case 6: return Dim6;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
            yield return Dim6;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6 }; }

        #endregion

        #region API        

                
        

        public TensorSize6 GetTensorHead()
        {
            return Head6;
        }         

        
        public (TensorSize6 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail6, idx);
        }

        public (TensorSize5 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
                        

            int idx = 0;
            int len = 1;

            idx += idx6 * len; len *= Dim6;
            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices7 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim6, out int idx6);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices7(idx0, idx1, idx2, idx3, idx4, idx5, idx6);
        }

        
        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize8
        : IReadOnlyList<int>
        , IEquatable<TensorSize8>        

    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public TensorSize8 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
             if (Dim6 != d6) throw new ArgumentException($"Dimension[6] mismatch; expect {d6}, but found {Dim6}");
             if (Dim7 != d7) throw new ArgumentException($"Dimension[7] mismatch; expect {d7}, but found {Dim7}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize8(ReadOnlySpan<int> dims)
        {
            return new TensorSize8(dims);
        }

        public TensorSize8(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
             Dim6 = d6;
             Dim7 = d7;
            
        }

        public TensorSize8(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 8) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
             Dim7 = dims[7];
            
        }

        public TensorSize8(IReadOnlyList<int> dims)
        {
            if (dims.Count != 8) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
             Dim7 = dims[7];
            
        }

        
        public TensorSize8(in TensorSize7 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
             Dim5 = head.Dim5;
             Dim6 = head.Dim6;
            
            Dim7 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7) Invalid = (-1, -1, -1, -1, -1, -1, -1, -1);

        
         public readonly int Dim0;
         public readonly int Dim1;
         public readonly int Dim2;
         public readonly int Dim3;
         public readonly int Dim4;
         public readonly int Dim5;
         public readonly int Dim6;
         public readonly int Dim7;
        
        public override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
             h ^= Dim6.GetHashCode(); h *=17;
             h ^= Dim7.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize8 a, in TensorSize8 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
             if (a.Dim6 != b.Dim6) return false;
             if (a.Dim7 != b.Dim7) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize8 a, in TensorSize8 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize8 a, in TensorSize8 b) { return !AreEqual(a,b); }

        public bool Equals(TensorSize8 other) { return AreEqual(this, other); }

        public override bool Equals(object obj) { return obj is TensorSize8 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Last =>  Dim7;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize6 Head6 => new TensorSize6(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize7 Head7 => new TensorSize7(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize1 Tail1 => new TensorSize1(Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize2 Tail2 => new TensorSize2(Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize3 Tail3 => new TensorSize3(Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize4 Tail4 => new TensorSize4(Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize5 Tail5 => new TensorSize5(Dim3, Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize6 Tail6 => new TensorSize6(Dim2, Dim3, Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public TensorSize7 Tail7 => new TensorSize7(Dim1, Dim2, Dim3, Dim4, Dim5, Dim6, Dim7);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5 * Dim6 * Dim7;

        #endregion

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public int Count => 8;

        public int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                    case 6: return Dim6;
                    case 7: return Dim7;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
            yield return Dim6;
            yield return Dim7;
        }

        public IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6, Dim7 }; }

        #endregion

        #region API        

                
        

        public TensorSize7 GetTensorHead()
        {
            return Head7;
        }         

        
        public (TensorSize7 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail7, idx);
        }

        public (TensorSize6 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail6, idx);
        }

        public (TensorSize5 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            idx += idx6 * len;  len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
            if (idx7 < 0 || idx7 >= Dim7) throw new IndexOutOfRangeException(nameof(idx7));
                        

            int idx = 0;
            int len = 1;

            idx += idx7 * len; len *= Dim7;
            idx += idx6 * len; len *= Dim6;
            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public TensorIndices8 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim7, out int idx7);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim6, out int idx6);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices8(idx0, idx1, idx2, idx3, idx4, idx5, idx6, idx7);
        }

        
        #endregion
    }

    
}
