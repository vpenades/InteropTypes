<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace InteropTypes.Tensors
{
    <# var TDIM_MAX = 8; #>

    <# for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT) { #>
    <# var TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int i{idx}")); #>

    <# var TTENSORINDICES = $"TensorIndices{TDIMCOUNT}"; #>

    /// <summary>
    /// Represents the indices of a specific element within a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public partial struct <#= TTENSORINDICES#> : IReadOnlyList<int>, IEquatable<<#= TTENSORINDICES#>>
    {
        #region debug

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }        

        #endregion

        #region lifecycle

        public static implicit operator <#= TTENSORINDICES#>(ReadOnlySpan<int> indices)
        {
            return new <#= TTENSORINDICES#>(indices);
        }        

        <# if (TDIMCOUNT == 1) { #>        

        <# } else { #>

        public static implicit operator <#= TTENSORINDICES#>(in (<#= TARGS#>) indices)
        {
            return new <#= TTENSORINDICES#>(indices);
        }

        public <#= TTENSORINDICES#>(in (<#= TARGS#>) indices)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices.i<#= TDIM#>;
            <# } #>

        }

        <# } #>

        public <#= TTENSORINDICES#>(<#= TARGS#>)
        {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = i<#= TDIM#>;
            <# } #>

        }

        public <#= TTENSORINDICES#>(ReadOnlySpan<int> indices)
        {
            if (indices.Length != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(indices));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices[<#= TDIM#>];
            <# } #>

        }

        public <#= TTENSORINDICES#>(IReadOnlyList<int> indices)
        {
            if (indices.Count != <#= TDIMCOUNT#>) throw new ArgumentOutOfRangeException(nameof(indices));

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> Index<#= TDIM#> = indices[<#= TDIM#>];
            <# } #>

        }        

        #endregion

        #region data

        <# if (TDIMCOUNT == 1) { #>

        <# } else { #>

        <# var TNEGXX = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => "-1")); #>
public static readonly <#= TTENSORINDICES#> Invalid = (<#= TNEGXX#>);

        <# } #>

        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> public int Index<#= TDIM#>;
        <# } #>

        public readonly override int GetHashCode()
        {
            int h=0;

            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> h ^= Index<#= TDIM#>.GetHashCode(); h *=17;
            <# } #>

            return h;
        }

        public static bool AreEqual(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b)
        {            
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #> if (a.Index<#= TDIM#> != b.Index<#= TDIM#>) return false;
            <# } #>

            return true;
        }

        public static bool operator ==(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b) { return AreEqual(a,b); }

        public static bool operator !=(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b) { return !AreEqual(a,b); }

        public readonly bool Equals(<#= TTENSORINDICES#> other) { return AreEqual(this, other); }

        public readonly override bool Equals(object obj) { return obj is <#= TTENSORINDICES#> other ? AreEqual(this, other) : false; }

        #endregion        

        #region API - List

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => <#= TDIMCOUNT#>;

        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
        case <#= TDIM#>: return Index<#= TDIM#>;
            <# } #>                    
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
        <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { #>
    yield return Index<#= TDIM#>;
        <# } #>
}

        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        <# var TITEMS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Index{idx}")); #>
public readonly int[] ToArray() { return new int[] { <#= TITEMS#> }; }        

        #endregion

        #region operators

        public static <#= TTENSORINDICES#> operator +(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b)        
        {
            return new <#= TTENSORINDICES#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Index<#= TDIM#> + b.Index<#= TDIM#> <# } #>);            
        }     

        public static <#= TTENSORINDICES#> operator -(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b)        
        {
            return new <#= TTENSORINDICES#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> a.Index<#= TDIM#> - b.Index<#= TDIM#> <# } #>);            
        }   

        public static <#= TTENSORINDICES#> Min(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b)        
        {
            return new <#= TTENSORINDICES#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> Math.Min(a.Index<#= TDIM#> , b.Index<#= TDIM#>) <# } #>);            
        } 

        public static <#= TTENSORINDICES#> Max(in <#= TTENSORINDICES#> a, in <#= TTENSORINDICES#> b)        
        {
            return new <#= TTENSORINDICES#>(
            <# for(var TDIM = 0; TDIM < TDIMCOUNT; ++TDIM) { if (TDIM > 0) #>, <#
            #> Math.Max(a.Index<#= TDIM#> , b.Index<#= TDIM#>) <# } #>);            
        } 

        #endregion

        #region API - Other

        <# if (TDIMCOUNT == 1) { #>        

        <# } else { #>

        <#
        TITEMS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"Index{idx}"));        
        var TRESULT = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int Index{idx}"));        
        #>
public readonly (<#= TRESULT#>) ToValueTuple() { return (<#= TITEMS#>); }

        <# } #>

        #endregion
    }

    <# } #>
}
