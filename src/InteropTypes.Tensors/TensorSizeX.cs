// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

namespace InteropTypes.Tensors
{
    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize1
        : IReadOnlyList<int>
        , IEquatable<TensorSize1>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize1 VerifyDimensions(int d0)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize1(ReadOnlySpan<int> dims)
        {
            return new TensorSize1(dims);
        }

        public static TensorSize1 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize1 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize1 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize1 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 1) return new TensorSize1(dims);

            Span<int> xdims = stackalloc int[1];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize1(xdims);
        }        

        public TensorSize1(int d0)
        {
             Dim0 = d0;
            
        }

        public TensorSize1(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 1) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
            
        }

        public TensorSize1(IReadOnlyList<int> dims)
        {
            if (dims.Count != 1) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
            
        }

        
        #endregion

        #region data

        
        
        public readonly int Dim0;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize1 a, in TensorSize1 b)
        {
             if (a.Dim0 != b.Dim0) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize1 a, in TensorSize1 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize1 a, in TensorSize1 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize1 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize1 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim0;

        
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 1;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0 }; }

        #endregion

        #region API

        public static TensorSize1 operator +(in TensorSize1 a, in TensorSize1 b)        
        {
            return new TensorSize1(
             a.Dim0 + b.Dim0 );            
        }     

        public static TensorSize1 operator -(in TensorSize1 a, in TensorSize1 b)        
        {
            return new TensorSize1(
             a.Dim0 - b.Dim0 );            
        }  

        public static TensorSize1 operator +(in TensorSize1 a, in TensorIndices1 b)        
        {
            return new TensorSize1(
             a.Dim0 + b.Index0 );            
        }     

        public static TensorSize1 operator -(in TensorSize1 a, in TensorIndices1 b)        
        {
            return new TensorSize1(
             a.Dim0 - b.Index0 );            
        }  

        public static TensorSize1 Min(in TensorSize1 a, in TensorSize1 b)        
        {
            return new TensorSize1(
             Math.Min(a.Dim0 , b.Dim0) );            
        }     

        public static TensorSize1 Max(in TensorSize1 a, in TensorSize1 b)        
        {
            return new TensorSize1(
             Math.Max(a.Dim0 , b.Dim0) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize1 ExclusiveUnion(TensorSize1 srcSize, ref TensorIndices1 srcOffset, TensorSize1 dstSize, ref TensorIndices1 dstOffset)
        {
            var s = TensorSize1.Min(srcSize, dstSize);

            s += TensorIndices1.Min(default, srcOffset);
            srcOffset = TensorIndices1.Max(default, srcOffset);

            s += TensorIndices1.Min(default, dstOffset);
            dstOffset = TensorIndices1.Max(default, dstOffset);
            
            srcSize = TensorSize1.Max(default, srcSize - srcOffset);
            dstSize = TensorSize1.Max(default, dstSize - dstOffset);

            s = TensorSize1.Min(srcSize, s);
            s = TensorSize1.Min(dstSize, s);
            s = TensorSize1.Max(default, s);

            return s;
        }


        
        
        
        readonly int GetItemIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        public readonly int DecomposeIndex(int index)
        {
            if (index < 0 || index >= Dim0) throw new IndexOutOfRangeException(nameof(index));
            return index;
        }

        
        public readonly bool ContainsIndices(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize1 left, TensorSize1 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize2
        : IReadOnlyList<int>
        , IEquatable<TensorSize2>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize2 VerifyDimensions(int d0, int d1)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize2(ReadOnlySpan<int> dims)
        {
            return new TensorSize2(dims);
        }

        public static TensorSize2 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize2 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize2 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize2 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 2) return new TensorSize2(dims);

            Span<int> xdims = stackalloc int[2];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize2(xdims);
        }        

        public TensorSize2(int d0, int d1)
        {
             Dim0 = d0;
             Dim1 = d1;
            
        }

        public TensorSize2(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 2) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
            
        }

        public TensorSize2(IReadOnlyList<int> dims)
        {
            if (dims.Count != 2) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
            
        }

        
        public TensorSize2(in TensorSize1 head, int tail)
        {
             Dim0 = head.Dim0;
            
            Dim1 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1) Invalid = (-1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize2 a, in TensorSize2 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize2 a, in TensorSize2 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize2 a, in TensorSize2 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize2 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize2 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim1;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim1);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 2;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1 }; }

        #endregion

        #region API

        public static TensorSize2 operator +(in TensorSize2 a, in TensorSize2 b)        
        {
            return new TensorSize2(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 );            
        }     

        public static TensorSize2 operator -(in TensorSize2 a, in TensorSize2 b)        
        {
            return new TensorSize2(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 );            
        }  

        public static TensorSize2 operator +(in TensorSize2 a, in TensorIndices2 b)        
        {
            return new TensorSize2(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 );            
        }     

        public static TensorSize2 operator -(in TensorSize2 a, in TensorIndices2 b)        
        {
            return new TensorSize2(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 );            
        }  

        public static TensorSize2 Min(in TensorSize2 a, in TensorSize2 b)        
        {
            return new TensorSize2(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) );            
        }     

        public static TensorSize2 Max(in TensorSize2 a, in TensorSize2 b)        
        {
            return new TensorSize2(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize2 ExclusiveUnion(TensorSize2 srcSize, ref TensorIndices2 srcOffset, TensorSize2 dstSize, ref TensorIndices2 dstOffset)
        {
            var s = TensorSize2.Min(srcSize, dstSize);

            s += TensorIndices2.Min(default, srcOffset);
            srcOffset = TensorIndices2.Max(default, srcOffset);

            s += TensorIndices2.Min(default, dstOffset);
            dstOffset = TensorIndices2.Max(default, dstOffset);
            
            srcSize = TensorSize2.Max(default, srcSize - srcOffset);
            dstSize = TensorSize2.Max(default, dstSize - dstOffset);

            s = TensorSize2.Min(srcSize, s);
            s = TensorSize2.Min(dstSize, s);
            s = TensorSize2.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize1 GetTensorHead()
        {
            return Head1;
        }         

        
        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices2 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices2(idx0, idx1);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize2 left, TensorSize2 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize3
        : IReadOnlyList<int>
        , IEquatable<TensorSize3>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize3 VerifyDimensions(int d0, int d1, int d2)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize3(ReadOnlySpan<int> dims)
        {
            return new TensorSize3(dims);
        }

        public static TensorSize3 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize3 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize3 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize3 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 3) return new TensorSize3(dims);

            Span<int> xdims = stackalloc int[3];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize3(xdims);
        }        

        public TensorSize3(int d0, int d1, int d2)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
            
        }

        public TensorSize3(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 3) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
            
        }

        public TensorSize3(IReadOnlyList<int> dims)
        {
            if (dims.Count != 3) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
            
        }

        
        public TensorSize3(in TensorSize2 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
            
            Dim2 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2) Invalid = (-1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize3 a, in TensorSize3 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize3 a, in TensorSize3 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize3 a, in TensorSize3 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize3 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize3 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim2;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim1, Dim2);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 3;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2 }; }

        #endregion

        #region API

        public static TensorSize3 operator +(in TensorSize3 a, in TensorSize3 b)        
        {
            return new TensorSize3(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 );            
        }     

        public static TensorSize3 operator -(in TensorSize3 a, in TensorSize3 b)        
        {
            return new TensorSize3(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 );            
        }  

        public static TensorSize3 operator +(in TensorSize3 a, in TensorIndices3 b)        
        {
            return new TensorSize3(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 );            
        }     

        public static TensorSize3 operator -(in TensorSize3 a, in TensorIndices3 b)        
        {
            return new TensorSize3(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 );            
        }  

        public static TensorSize3 Min(in TensorSize3 a, in TensorSize3 b)        
        {
            return new TensorSize3(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) );            
        }     

        public static TensorSize3 Max(in TensorSize3 a, in TensorSize3 b)        
        {
            return new TensorSize3(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize3 ExclusiveUnion(TensorSize3 srcSize, ref TensorIndices3 srcOffset, TensorSize3 dstSize, ref TensorIndices3 dstOffset)
        {
            var s = TensorSize3.Min(srcSize, dstSize);

            s += TensorIndices3.Min(default, srcOffset);
            srcOffset = TensorIndices3.Max(default, srcOffset);

            s += TensorIndices3.Min(default, dstOffset);
            dstOffset = TensorIndices3.Max(default, dstOffset);
            
            srcSize = TensorSize3.Max(default, srcSize - srcOffset);
            dstSize = TensorSize3.Max(default, dstSize - dstOffset);

            s = TensorSize3.Min(srcSize, s);
            s = TensorSize3.Min(dstSize, s);
            s = TensorSize3.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize2 GetTensorHead()
        {
            return Head2;
        }         

        
        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices3 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices3(idx0, idx1, idx2);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize3 left, TensorSize3 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize4
        : IReadOnlyList<int>
        , IEquatable<TensorSize4>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize4 VerifyDimensions(int d0, int d1, int d2, int d3)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize4(ReadOnlySpan<int> dims)
        {
            return new TensorSize4(dims);
        }

        public static TensorSize4 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize4 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize4 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize4 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 4) return new TensorSize4(dims);

            Span<int> xdims = stackalloc int[4];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize4(xdims);
        }        

        public TensorSize4(int d0, int d1, int d2, int d3)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
            
        }

        public TensorSize4(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 4) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
            
        }

        public TensorSize4(IReadOnlyList<int> dims)
        {
            if (dims.Count != 4) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
            
        }

        
        public TensorSize4(in TensorSize3 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
            
            Dim3 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3) Invalid = (-1, -1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        public readonly int Dim3;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize4 a, in TensorSize4 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize4 a, in TensorSize4 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize4 a, in TensorSize4 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize4 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize4 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim3;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Tail3 => new TensorSize3(Dim1, Dim2, Dim3);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2 * Dim3;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 4;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3 }; }

        #endregion

        #region API

        public static TensorSize4 operator +(in TensorSize4 a, in TensorSize4 b)        
        {
            return new TensorSize4(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 ,  a.Dim3 + b.Dim3 );            
        }     

        public static TensorSize4 operator -(in TensorSize4 a, in TensorSize4 b)        
        {
            return new TensorSize4(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 ,  a.Dim3 - b.Dim3 );            
        }  

        public static TensorSize4 operator +(in TensorSize4 a, in TensorIndices4 b)        
        {
            return new TensorSize4(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 ,  a.Dim3 + b.Index3 );            
        }     

        public static TensorSize4 operator -(in TensorSize4 a, in TensorIndices4 b)        
        {
            return new TensorSize4(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 ,  a.Dim3 - b.Index3 );            
        }  

        public static TensorSize4 Min(in TensorSize4 a, in TensorSize4 b)        
        {
            return new TensorSize4(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) ,  Math.Min(a.Dim3 , b.Dim3) );            
        }     

        public static TensorSize4 Max(in TensorSize4 a, in TensorSize4 b)        
        {
            return new TensorSize4(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) ,  Math.Max(a.Dim3 , b.Dim3) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize4 ExclusiveUnion(TensorSize4 srcSize, ref TensorIndices4 srcOffset, TensorSize4 dstSize, ref TensorIndices4 dstOffset)
        {
            var s = TensorSize4.Min(srcSize, dstSize);

            s += TensorIndices4.Min(default, srcOffset);
            srcOffset = TensorIndices4.Max(default, srcOffset);

            s += TensorIndices4.Min(default, dstOffset);
            dstOffset = TensorIndices4.Max(default, dstOffset);
            
            srcSize = TensorSize4.Max(default, srcSize - srcOffset);
            dstSize = TensorSize4.Max(default, dstSize - dstOffset);

            s = TensorSize4.Min(srcSize, s);
            s = TensorSize4.Min(dstSize, s);
            s = TensorSize4.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize3 GetTensorHead()
        {
            return Head3;
        }         

        
        public readonly (TensorSize3 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices4 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices4(idx0, idx1, idx2, idx3);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            if (idx3 < 0 || idx3 >= Dim3) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize4 left, TensorSize4 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize5
        : IReadOnlyList<int>
        , IEquatable<TensorSize5>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize5 VerifyDimensions(int d0, int d1, int d2, int d3, int d4)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize5(ReadOnlySpan<int> dims)
        {
            return new TensorSize5(dims);
        }

        public static TensorSize5 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize5 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize5 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize5 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 5) return new TensorSize5(dims);

            Span<int> xdims = stackalloc int[5];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize5(xdims);
        }        

        public TensorSize5(int d0, int d1, int d2, int d3, int d4)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
            
        }

        public TensorSize5(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 5) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
            
        }

        public TensorSize5(IReadOnlyList<int> dims)
        {
            if (dims.Count != 5) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
            
        }

        
        public TensorSize5(in TensorSize4 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
            
            Dim4 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4) Invalid = (-1, -1, -1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        public readonly int Dim3;
        public readonly int Dim4;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize5 a, in TensorSize5 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize5 a, in TensorSize5 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize5 a, in TensorSize5 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize5 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize5 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim4;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Tail3 => new TensorSize3(Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Tail4 => new TensorSize4(Dim1, Dim2, Dim3, Dim4);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 5;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4 }; }

        #endregion

        #region API

        public static TensorSize5 operator +(in TensorSize5 a, in TensorSize5 b)        
        {
            return new TensorSize5(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 ,  a.Dim3 + b.Dim3 ,  a.Dim4 + b.Dim4 );            
        }     

        public static TensorSize5 operator -(in TensorSize5 a, in TensorSize5 b)        
        {
            return new TensorSize5(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 ,  a.Dim3 - b.Dim3 ,  a.Dim4 - b.Dim4 );            
        }  

        public static TensorSize5 operator +(in TensorSize5 a, in TensorIndices5 b)        
        {
            return new TensorSize5(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 ,  a.Dim3 + b.Index3 ,  a.Dim4 + b.Index4 );            
        }     

        public static TensorSize5 operator -(in TensorSize5 a, in TensorIndices5 b)        
        {
            return new TensorSize5(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 ,  a.Dim3 - b.Index3 ,  a.Dim4 - b.Index4 );            
        }  

        public static TensorSize5 Min(in TensorSize5 a, in TensorSize5 b)        
        {
            return new TensorSize5(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) ,  Math.Min(a.Dim3 , b.Dim3) ,  Math.Min(a.Dim4 , b.Dim4) );            
        }     

        public static TensorSize5 Max(in TensorSize5 a, in TensorSize5 b)        
        {
            return new TensorSize5(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) ,  Math.Max(a.Dim3 , b.Dim3) ,  Math.Max(a.Dim4 , b.Dim4) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize5 ExclusiveUnion(TensorSize5 srcSize, ref TensorIndices5 srcOffset, TensorSize5 dstSize, ref TensorIndices5 dstOffset)
        {
            var s = TensorSize5.Min(srcSize, dstSize);

            s += TensorIndices5.Min(default, srcOffset);
            srcOffset = TensorIndices5.Max(default, srcOffset);

            s += TensorIndices5.Min(default, dstOffset);
            dstOffset = TensorIndices5.Max(default, dstOffset);
            
            srcSize = TensorSize5.Max(default, srcSize - srcOffset);
            dstSize = TensorSize5.Max(default, dstSize - dstOffset);

            s = TensorSize5.Min(srcSize, s);
            s = TensorSize5.Min(dstSize, s);
            s = TensorSize5.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize4 GetTensorHead()
        {
            return Head4;
        }         

        
        public readonly (TensorSize4 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public readonly (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices5 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices5(idx0, idx1, idx2, idx3, idx4);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            if (idx3 < 0 || idx3 >= Dim3) return false;
            if (idx4 < 0 || idx4 >= Dim4) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize5 left, TensorSize5 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize6
        : IReadOnlyList<int>
        , IEquatable<TensorSize6>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize6 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize6(ReadOnlySpan<int> dims)
        {
            return new TensorSize6(dims);
        }

        public static TensorSize6 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize6 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize6 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize6 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 6) return new TensorSize6(dims);

            Span<int> xdims = stackalloc int[6];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize6(xdims);
        }        

        public TensorSize6(int d0, int d1, int d2, int d3, int d4, int d5)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
            
        }

        public TensorSize6(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 6) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
            
        }

        public TensorSize6(IReadOnlyList<int> dims)
        {
            if (dims.Count != 6) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
            
        }

        
        public TensorSize6(in TensorSize5 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
            
            Dim5 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5) Invalid = (-1, -1, -1, -1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        public readonly int Dim3;
        public readonly int Dim4;
        public readonly int Dim5;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize6 a, in TensorSize6 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize6 a, in TensorSize6 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize6 a, in TensorSize6 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize6 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize6 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim5;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Tail3 => new TensorSize3(Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Tail4 => new TensorSize4(Dim2, Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Tail5 => new TensorSize5(Dim1, Dim2, Dim3, Dim4, Dim5);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 6;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5 }; }

        #endregion

        #region API

        public static TensorSize6 operator +(in TensorSize6 a, in TensorSize6 b)        
        {
            return new TensorSize6(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 ,  a.Dim3 + b.Dim3 ,  a.Dim4 + b.Dim4 ,  a.Dim5 + b.Dim5 );            
        }     

        public static TensorSize6 operator -(in TensorSize6 a, in TensorSize6 b)        
        {
            return new TensorSize6(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 ,  a.Dim3 - b.Dim3 ,  a.Dim4 - b.Dim4 ,  a.Dim5 - b.Dim5 );            
        }  

        public static TensorSize6 operator +(in TensorSize6 a, in TensorIndices6 b)        
        {
            return new TensorSize6(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 ,  a.Dim3 + b.Index3 ,  a.Dim4 + b.Index4 ,  a.Dim5 + b.Index5 );            
        }     

        public static TensorSize6 operator -(in TensorSize6 a, in TensorIndices6 b)        
        {
            return new TensorSize6(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 ,  a.Dim3 - b.Index3 ,  a.Dim4 - b.Index4 ,  a.Dim5 - b.Index5 );            
        }  

        public static TensorSize6 Min(in TensorSize6 a, in TensorSize6 b)        
        {
            return new TensorSize6(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) ,  Math.Min(a.Dim3 , b.Dim3) ,  Math.Min(a.Dim4 , b.Dim4) ,  Math.Min(a.Dim5 , b.Dim5) );            
        }     

        public static TensorSize6 Max(in TensorSize6 a, in TensorSize6 b)        
        {
            return new TensorSize6(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) ,  Math.Max(a.Dim3 , b.Dim3) ,  Math.Max(a.Dim4 , b.Dim4) ,  Math.Max(a.Dim5 , b.Dim5) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize6 ExclusiveUnion(TensorSize6 srcSize, ref TensorIndices6 srcOffset, TensorSize6 dstSize, ref TensorIndices6 dstOffset)
        {
            var s = TensorSize6.Min(srcSize, dstSize);

            s += TensorIndices6.Min(default, srcOffset);
            srcOffset = TensorIndices6.Max(default, srcOffset);

            s += TensorIndices6.Min(default, dstOffset);
            dstOffset = TensorIndices6.Max(default, dstOffset);
            
            srcSize = TensorSize6.Max(default, srcSize - srcOffset);
            dstSize = TensorSize6.Max(default, dstSize - dstOffset);

            s = TensorSize6.Min(srcSize, s);
            s = TensorSize6.Min(dstSize, s);
            s = TensorSize6.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize5 GetTensorHead()
        {
            return Head5;
        }         

        
        public readonly (TensorSize5 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public readonly (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public readonly (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices6 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices6(idx0, idx1, idx2, idx3, idx4, idx5);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            if (idx3 < 0 || idx3 >= Dim3) return false;
            if (idx4 < 0 || idx4 >= Dim4) return false;
            if (idx5 < 0 || idx5 >= Dim5) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize6 left, TensorSize6 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize7
        : IReadOnlyList<int>
        , IEquatable<TensorSize7>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize7 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
             if (Dim6 != d6) throw new ArgumentException($"Dimension[6] mismatch; expect {d6}, but found {Dim6}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize7(ReadOnlySpan<int> dims)
        {
            return new TensorSize7(dims);
        }

        public static TensorSize7 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize7 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize7 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize7 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 7) return new TensorSize7(dims);

            Span<int> xdims = stackalloc int[7];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize7(xdims);
        }        

        public TensorSize7(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
             Dim6 = d6;
            
        }

        public TensorSize7(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 7) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
            
        }

        public TensorSize7(IReadOnlyList<int> dims)
        {
            if (dims.Count != 7) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
            
        }

        
        public TensorSize7(in TensorSize6 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
             Dim5 = head.Dim5;
            
            Dim6 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6) Invalid = (-1, -1, -1, -1, -1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        public readonly int Dim3;
        public readonly int Dim4;
        public readonly int Dim5;
        public readonly int Dim6;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
             h ^= Dim6.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize7 a, in TensorSize7 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
             if (a.Dim6 != b.Dim6) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize7 a, in TensorSize7 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize7 a, in TensorSize7 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize7 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize7 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim6;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize6 Head6 => new TensorSize6(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Tail3 => new TensorSize3(Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Tail4 => new TensorSize4(Dim3, Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Tail5 => new TensorSize5(Dim2, Dim3, Dim4, Dim5, Dim6);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize6 Tail6 => new TensorSize6(Dim1, Dim2, Dim3, Dim4, Dim5, Dim6);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5 * Dim6;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 7;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                    case 6: return Dim6;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
            yield return Dim6;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6 }; }

        #endregion

        #region API

        public static TensorSize7 operator +(in TensorSize7 a, in TensorSize7 b)        
        {
            return new TensorSize7(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 ,  a.Dim3 + b.Dim3 ,  a.Dim4 + b.Dim4 ,  a.Dim5 + b.Dim5 ,  a.Dim6 + b.Dim6 );            
        }     

        public static TensorSize7 operator -(in TensorSize7 a, in TensorSize7 b)        
        {
            return new TensorSize7(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 ,  a.Dim3 - b.Dim3 ,  a.Dim4 - b.Dim4 ,  a.Dim5 - b.Dim5 ,  a.Dim6 - b.Dim6 );            
        }  

        public static TensorSize7 operator +(in TensorSize7 a, in TensorIndices7 b)        
        {
            return new TensorSize7(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 ,  a.Dim3 + b.Index3 ,  a.Dim4 + b.Index4 ,  a.Dim5 + b.Index5 ,  a.Dim6 + b.Index6 );            
        }     

        public static TensorSize7 operator -(in TensorSize7 a, in TensorIndices7 b)        
        {
            return new TensorSize7(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 ,  a.Dim3 - b.Index3 ,  a.Dim4 - b.Index4 ,  a.Dim5 - b.Index5 ,  a.Dim6 - b.Index6 );            
        }  

        public static TensorSize7 Min(in TensorSize7 a, in TensorSize7 b)        
        {
            return new TensorSize7(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) ,  Math.Min(a.Dim3 , b.Dim3) ,  Math.Min(a.Dim4 , b.Dim4) ,  Math.Min(a.Dim5 , b.Dim5) ,  Math.Min(a.Dim6 , b.Dim6) );            
        }     

        public static TensorSize7 Max(in TensorSize7 a, in TensorSize7 b)        
        {
            return new TensorSize7(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) ,  Math.Max(a.Dim3 , b.Dim3) ,  Math.Max(a.Dim4 , b.Dim4) ,  Math.Max(a.Dim5 , b.Dim5) ,  Math.Max(a.Dim6 , b.Dim6) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize7 ExclusiveUnion(TensorSize7 srcSize, ref TensorIndices7 srcOffset, TensorSize7 dstSize, ref TensorIndices7 dstOffset)
        {
            var s = TensorSize7.Min(srcSize, dstSize);

            s += TensorIndices7.Min(default, srcOffset);
            srcOffset = TensorIndices7.Max(default, srcOffset);

            s += TensorIndices7.Min(default, dstOffset);
            dstOffset = TensorIndices7.Max(default, dstOffset);
            
            srcSize = TensorSize7.Max(default, srcSize - srcOffset);
            dstSize = TensorSize7.Max(default, dstSize - dstOffset);

            s = TensorSize7.Min(srcSize, s);
            s = TensorSize7.Min(dstSize, s);
            s = TensorSize7.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize6 GetTensorHead()
        {
            return Head6;
        }         

        
        public readonly (TensorSize6 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail6, idx);
        }

        public readonly (TensorSize5 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public readonly (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public readonly (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
                        

            int idx = 0;
            int len = 1;

            idx += idx6 * len; len *= Dim6;
            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices7 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim6, out int idx6);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices7(idx0, idx1, idx2, idx3, idx4, idx5, idx6);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            if (idx3 < 0 || idx3 >= Dim3) return false;
            if (idx4 < 0 || idx4 >= Dim4) return false;
            if (idx5 < 0 || idx5 >= Dim5) return false;
            if (idx6 < 0 || idx6 >= Dim6) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize7 left, TensorSize7 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
    /// <summary>
    /// Represents the dimensions of a tensor.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public readonly partial struct TensorSize8
        : IReadOnlyList<int>
        , IEquatable<TensorSize8>
    {
        #region diagnostics

        private readonly string _GetDebuggerDisplayString()
        {
            return string.Join("×", this);
        }

        public readonly TensorSize8 VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
             if (Dim0 != d0) throw new ArgumentException($"Dimension[0] mismatch; expect {d0}, but found {Dim0}");
             if (Dim1 != d1) throw new ArgumentException($"Dimension[1] mismatch; expect {d1}, but found {Dim1}");
             if (Dim2 != d2) throw new ArgumentException($"Dimension[2] mismatch; expect {d2}, but found {Dim2}");
             if (Dim3 != d3) throw new ArgumentException($"Dimension[3] mismatch; expect {d3}, but found {Dim3}");
             if (Dim4 != d4) throw new ArgumentException($"Dimension[4] mismatch; expect {d4}, but found {Dim4}");
             if (Dim5 != d5) throw new ArgumentException($"Dimension[5] mismatch; expect {d5}, but found {Dim5}");
             if (Dim6 != d6) throw new ArgumentException($"Dimension[6] mismatch; expect {d6}, but found {Dim6}");
             if (Dim7 != d7) throw new ArgumentException($"Dimension[7] mismatch; expect {d7}, but found {Dim7}");
            
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator TensorSize8(ReadOnlySpan<int> dims)
        {
            return new TensorSize8(dims);
        }

        public static TensorSize8 FromAny(IReadOnlyList<int> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = dims[i];
            return FromAny(xdims);
        }

        public static TensorSize8 FromAny(IReadOnlyList<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Count];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize8 FromAny(ReadOnlySpan<long> dims)
        {
            Span<int> xdims = stackalloc int[dims.Length];
            for(int i=0; i < xdims.Length; ++i) xdims[i] = (int)dims[i];
            return FromAny(xdims);
        }

        public static TensorSize8 FromAny(ReadOnlySpan<int> dims)
        {
            if (dims.Length == 8) return new TensorSize8(dims);

            Span<int> xdims = stackalloc int[8];

            _ArrayUtilities.FillDimensionsFromAny(xdims, dims);

            return new TensorSize8(xdims);
        }        

        public TensorSize8(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
             Dim0 = d0;
             Dim1 = d1;
             Dim2 = d2;
             Dim3 = d3;
             Dim4 = d4;
             Dim5 = d5;
             Dim6 = d6;
             Dim7 = d7;
            
        }

        public TensorSize8(ReadOnlySpan<int> dims)
        {
            if (dims.Length != 8) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
             Dim7 = dims[7];
            
        }

        public TensorSize8(IReadOnlyList<int> dims)
        {
            if (dims.Count != 8) throw new ArgumentOutOfRangeException(nameof(dims));

             Dim0 = dims[0];
             Dim1 = dims[1];
             Dim2 = dims[2];
             Dim3 = dims[3];
             Dim4 = dims[4];
             Dim5 = dims[5];
             Dim6 = dims[6];
             Dim7 = dims[7];
            
        }

        
        public TensorSize8(in TensorSize7 head, int tail)
        {
             Dim0 = head.Dim0;
             Dim1 = head.Dim1;
             Dim2 = head.Dim2;
             Dim3 = head.Dim3;
             Dim4 = head.Dim4;
             Dim5 = head.Dim5;
             Dim6 = head.Dim6;
            
            Dim7 = tail;
        }

        
        #endregion

        #region data

        
        public static readonly (int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7) Invalid = (-1, -1, -1, -1, -1, -1, -1, -1);

        
        public readonly int Dim0;
        public readonly int Dim1;
        public readonly int Dim2;
        public readonly int Dim3;
        public readonly int Dim4;
        public readonly int Dim5;
        public readonly int Dim6;
        public readonly int Dim7;
        
        /// <inheritdoc/>
        public readonly override int GetHashCode()
        {
            int h=0;

             h ^= Dim0.GetHashCode(); h *=17;
             h ^= Dim1.GetHashCode(); h *=17;
             h ^= Dim2.GetHashCode(); h *=17;
             h ^= Dim3.GetHashCode(); h *=17;
             h ^= Dim4.GetHashCode(); h *=17;
             h ^= Dim5.GetHashCode(); h *=17;
             h ^= Dim6.GetHashCode(); h *=17;
             h ^= Dim7.GetHashCode(); h *=17;
                        
            return h;
        }

        public static bool AreEqual(in TensorSize8 a, in TensorSize8 b)
        {
             if (a.Dim0 != b.Dim0) return false;
             if (a.Dim1 != b.Dim1) return false;
             if (a.Dim2 != b.Dim2) return false;
             if (a.Dim3 != b.Dim3) return false;
             if (a.Dim4 != b.Dim4) return false;
             if (a.Dim5 != b.Dim5) return false;
             if (a.Dim6 != b.Dim6) return false;
             if (a.Dim7 != b.Dim7) return false;
            
            return true;
        }        

        public static bool operator ==(in TensorSize8 a, in TensorSize8 b) { return AreEqual(a,b); }

        public static bool operator !=(in TensorSize8 a, in TensorSize8 b) { return !AreEqual(a,b); }

        /// <inheritdoc/>
        public readonly bool Equals(TensorSize8 other) { return AreEqual(this, other); }

        /// <inheritdoc/>
        public readonly override bool Equals(object obj) { return obj is TensorSize8 other ? AreEqual(this, other) : false; }

        #endregion

        #region properties

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Last =>  Dim7;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Head1 => new TensorSize1(Dim0);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Head2 => new TensorSize2(Dim0, Dim1);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Head3 => new TensorSize3(Dim0, Dim1, Dim2);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Head4 => new TensorSize4(Dim0, Dim1, Dim2, Dim3);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Head5 => new TensorSize5(Dim0, Dim1, Dim2, Dim3, Dim4);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize6 Head6 => new TensorSize6(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize7 Head7 => new TensorSize7(Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6);
        
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize1 Tail1 => new TensorSize1(Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize2 Tail2 => new TensorSize2(Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize3 Tail3 => new TensorSize3(Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize4 Tail4 => new TensorSize4(Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize5 Tail5 => new TensorSize5(Dim3, Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize6 Tail6 => new TensorSize6(Dim2, Dim3, Dim4, Dim5, Dim6, Dim7);
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly TensorSize7 Tail7 => new TensorSize7(Dim1, Dim2, Dim3, Dim4, Dim5, Dim6, Dim7);
        
        
        /// <Remarks>
        /// The total number of elements (computed as the dot product of the dimensions)
        /// </Remarks>
        public readonly int StepSize => Dim0 * Dim1 * Dim2 * Dim3 * Dim4 * Dim5 * Dim6 * Dim7;

        #endregion

        #region API - List

        /// <inheritdoc/>
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public readonly int Count => 8;

        /// <inheritdoc/>
        public readonly int this[int index]
        {
            get
            {
                switch(index)
                {
                    case 0: return Dim0;
                    case 1: return Dim1;
                    case 2: return Dim2;
                    case 3: return Dim3;
                    case 4: return Dim4;
                    case 5: return Dim5;
                    case 6: return Dim6;
                    case 7: return Dim7;
                                
                    default:throw new ArgumentOutOfRangeException(nameof(index));
                }
            }
        }

        private readonly IEnumerable<int> _Enumerate()
        {
            yield return Dim0;
            yield return Dim1;
            yield return Dim2;
            yield return Dim3;
            yield return Dim4;
            yield return Dim5;
            yield return Dim6;
            yield return Dim7;
        }

        /// <inheritdoc/>
        public readonly IEnumerator<int> GetEnumerator() { return _Enumerate().GetEnumerator(); }

        readonly IEnumerator IEnumerable.GetEnumerator() { return _Enumerate().GetEnumerator(); }

        public readonly int[] ToArray() { return new int[] { Dim0, Dim1, Dim2, Dim3, Dim4, Dim5, Dim6, Dim7 }; }

        #endregion

        #region API

        public static TensorSize8 operator +(in TensorSize8 a, in TensorSize8 b)        
        {
            return new TensorSize8(
             a.Dim0 + b.Dim0 ,  a.Dim1 + b.Dim1 ,  a.Dim2 + b.Dim2 ,  a.Dim3 + b.Dim3 ,  a.Dim4 + b.Dim4 ,  a.Dim5 + b.Dim5 ,  a.Dim6 + b.Dim6 ,  a.Dim7 + b.Dim7 );            
        }     

        public static TensorSize8 operator -(in TensorSize8 a, in TensorSize8 b)        
        {
            return new TensorSize8(
             a.Dim0 - b.Dim0 ,  a.Dim1 - b.Dim1 ,  a.Dim2 - b.Dim2 ,  a.Dim3 - b.Dim3 ,  a.Dim4 - b.Dim4 ,  a.Dim5 - b.Dim5 ,  a.Dim6 - b.Dim6 ,  a.Dim7 - b.Dim7 );            
        }  

        public static TensorSize8 operator +(in TensorSize8 a, in TensorIndices8 b)        
        {
            return new TensorSize8(
             a.Dim0 + b.Index0 ,  a.Dim1 + b.Index1 ,  a.Dim2 + b.Index2 ,  a.Dim3 + b.Index3 ,  a.Dim4 + b.Index4 ,  a.Dim5 + b.Index5 ,  a.Dim6 + b.Index6 ,  a.Dim7 + b.Index7 );            
        }     

        public static TensorSize8 operator -(in TensorSize8 a, in TensorIndices8 b)        
        {
            return new TensorSize8(
             a.Dim0 - b.Index0 ,  a.Dim1 - b.Index1 ,  a.Dim2 - b.Index2 ,  a.Dim3 - b.Index3 ,  a.Dim4 - b.Index4 ,  a.Dim5 - b.Index5 ,  a.Dim6 - b.Index6 ,  a.Dim7 - b.Index7 );            
        }  

        public static TensorSize8 Min(in TensorSize8 a, in TensorSize8 b)        
        {
            return new TensorSize8(
             Math.Min(a.Dim0 , b.Dim0) ,  Math.Min(a.Dim1 , b.Dim1) ,  Math.Min(a.Dim2 , b.Dim2) ,  Math.Min(a.Dim3 , b.Dim3) ,  Math.Min(a.Dim4 , b.Dim4) ,  Math.Min(a.Dim5 , b.Dim5) ,  Math.Min(a.Dim6 , b.Dim6) ,  Math.Min(a.Dim7 , b.Dim7) );            
        }     

        public static TensorSize8 Max(in TensorSize8 a, in TensorSize8 b)        
        {
            return new TensorSize8(
             Math.Max(a.Dim0 , b.Dim0) ,  Math.Max(a.Dim1 , b.Dim1) ,  Math.Max(a.Dim2 , b.Dim2) ,  Math.Max(a.Dim3 , b.Dim3) ,  Math.Max(a.Dim4 , b.Dim4) ,  Math.Max(a.Dim5 , b.Dim5) ,  Math.Max(a.Dim6 , b.Dim6) ,  Math.Max(a.Dim7 , b.Dim7) );            
        }  

        /// <Summary>
        /// Calculates the exclusive union between two offset tensors 
        /// </Summary>
        public static TensorSize8 ExclusiveUnion(TensorSize8 srcSize, ref TensorIndices8 srcOffset, TensorSize8 dstSize, ref TensorIndices8 dstOffset)
        {
            var s = TensorSize8.Min(srcSize, dstSize);

            s += TensorIndices8.Min(default, srcOffset);
            srcOffset = TensorIndices8.Max(default, srcOffset);

            s += TensorIndices8.Min(default, dstOffset);
            dstOffset = TensorIndices8.Max(default, dstOffset);
            
            srcSize = TensorSize8.Max(default, srcSize - srcOffset);
            dstSize = TensorSize8.Max(default, dstSize - dstOffset);

            s = TensorSize8.Min(srcSize, s);
            s = TensorSize8.Min(dstSize, s);
            s = TensorSize8.Max(default, s);

            return s;
        }


                
        

        public readonly TensorSize7 GetTensorHead()
        {
            return Head7;
        }         

        
        public readonly (TensorSize7 dims, int offs) GetTensorTail(int idx0)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail7, idx);
        }

        public readonly (TensorSize6 dims, int offs) GetTensorTail(int idx0, int idx1)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail6, idx);
        }

        public readonly (TensorSize5 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail5, idx);
        }

        public readonly (TensorSize4 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail4, idx);
        }

        public readonly (TensorSize3 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail3, idx);
        }

        public readonly (TensorSize2 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail2, idx);
        }

        public readonly (TensorSize1 dims, int offs) GetTensorTail(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
                        

            int idx = 0;
            int len = 1;

            len *= Dim7;
            idx += idx6 * len;  len *= Dim6;
            idx += idx5 * len;  len *= Dim5;
            idx += idx4 * len;  len *= Dim4;
            idx += idx3 * len;  len *= Dim3;
            idx += idx2 * len;  len *= Dim2;
            idx += idx1 * len;  len *= Dim1;
                        
            idx += idx0 * len;            
            
            return (Tail1, idx);
        }

        
        


        public readonly int GetFlattenedIndex(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7)
        {
            if (idx0 < 0 || idx0 >= Dim0) throw new IndexOutOfRangeException(nameof(idx0));
            if (idx1 < 0 || idx1 >= Dim1) throw new IndexOutOfRangeException(nameof(idx1));
            if (idx2 < 0 || idx2 >= Dim2) throw new IndexOutOfRangeException(nameof(idx2));
            if (idx3 < 0 || idx3 >= Dim3) throw new IndexOutOfRangeException(nameof(idx3));
            if (idx4 < 0 || idx4 >= Dim4) throw new IndexOutOfRangeException(nameof(idx4));
            if (idx5 < 0 || idx5 >= Dim5) throw new IndexOutOfRangeException(nameof(idx5));
            if (idx6 < 0 || idx6 >= Dim6) throw new IndexOutOfRangeException(nameof(idx6));
            if (idx7 < 0 || idx7 >= Dim7) throw new IndexOutOfRangeException(nameof(idx7));
                        

            int idx = 0;
            int len = 1;

            idx += idx7 * len; len *= Dim7;
            idx += idx6 * len; len *= Dim6;
            idx += idx5 * len; len *= Dim5;
            idx += idx4 * len; len *= Dim4;
            idx += idx3 * len; len *= Dim3;
            idx += idx2 * len; len *= Dim2;
            idx += idx1 * len; len *= Dim1;
            idx += idx0 * len;
            
            return idx;
        }
        
        /// <summary>
        /// Gets the indices of each dimension from a flattend index.
        /// </summary>
        /// <param name="flattenedIndex">a flattened index</param>
        /// <returns>The indices for each dimension</returns>
        public readonly TensorIndices8 GetDecomposedIndex(int flattenedIndex)
        {
            if (flattenedIndex < 0 || flattenedIndex >= StepSize) throw new IndexOutOfRangeException(nameof(flattenedIndex));

            flattenedIndex = Math.DivRem(flattenedIndex, Dim7, out int idx7);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim6, out int idx6);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim5, out int idx5);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim4, out int idx4);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim3, out int idx3);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim2, out int idx2);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim1, out int idx1);
            flattenedIndex = Math.DivRem(flattenedIndex, Dim0, out int idx0);

            return new TensorIndices8(idx0, idx1, idx2, idx3, idx4, idx5, idx6, idx7);
        }

        
        public readonly bool ContainsIndices(int idx0, int idx1, int idx2, int idx3, int idx4, int idx5, int idx6, int idx7)
        {
            if (idx0 < 0 || idx0 >= Dim0) return false;
            if (idx1 < 0 || idx1 >= Dim1) return false;
            if (idx2 < 0 || idx2 >= Dim2) return false;
            if (idx3 < 0 || idx3 >= Dim3) return false;
            if (idx4 < 0 || idx4 >= Dim4) return false;
            if (idx5 < 0 || idx5 >= Dim5) return false;
            if (idx6 < 0 || idx6 >= Dim6) return false;
            if (idx7 < 0 || idx7 >= Dim7) return false;
            
            return true;
        }

        #endregion

        #region guard

        [System.Diagnostics.DebuggerStepThrough]
        public static void GuardEquals(string leftname, string rightname, TensorSize8 left, TensorSize8 right)
        {
            if (left != right) throw new ArgumentException($"{leftname} and {rightname} must have the same size");
        }        

        #endregion
    }

    
}
