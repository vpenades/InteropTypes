// <auto-generated />
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Numerics.Tensors;
using System.Text;

using MEMORYMARSHALL = System.Runtime.InteropServices.MemoryMarshal;

namespace InteropTypes.Tensors
{
    
    /// <summary>
    /// Represents a dense tensor of 1 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor1<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor1<T> VerifyDimensions(int d0)
        {
            
            _Dimensions.VerifyDimensions(d0);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor1<T> AsReadOnly() => new ReadOnlySpanTensor1<T>(this);
        public SpanTensor1(TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor1(int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor1(Span<T> data, TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor1(Span<T> data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor1(IntPtr data, TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor1(IntPtr data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor1<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize1 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize1 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public T this[int idx]
        {
            readonly       
            get => _Buffer[idx];
            set => _Buffer[idx] = value;
                        
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor1<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

   
        

        
        
        public readonly unsafe SpanTensor2<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize2(_Dimensions, last);

            return new SpanTensor2<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 2 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor2<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor2<T> VerifyDimensions(int d0, int d1)
        {
            
            _Dimensions.VerifyDimensions(d0, d1);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor2<T> AsReadOnly() => new ReadOnlySpanTensor2<T>(this);
        public SpanTensor2(TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor2(int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor2(Span<T> data, TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor2(Span<T> data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor2(IntPtr data, TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor2(IntPtr data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor2<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize2 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize2 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor1<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor2<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor1<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail1) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor1<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor1<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor2<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor2<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize2(_Dimensions.Head1, lastDim);            

                return new SpanTensor2<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor1<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor1<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor1<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor2<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly unsafe SpanTensor3<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize3(_Dimensions, last);

            return new SpanTensor3<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 3 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor3<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor3<T> VerifyDimensions(int d0, int d1, int d2)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor3<T> AsReadOnly() => new ReadOnlySpanTensor3<T>(this);
        public SpanTensor3(TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor3(int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor3(Span<T> data, TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor3(Span<T> data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor3(IntPtr data, TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor3(IntPtr data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor3<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize3 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize3 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor2<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor3<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor2<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail2) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor2<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor2<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor3<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor3<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize3(_Dimensions.Head2, lastDim);            

                return new SpanTensor3<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor2<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor2<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor2<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor3<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly unsafe SpanTensor4<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize4(_Dimensions, last);

            return new SpanTensor4<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 4 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor4<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor4<T> VerifyDimensions(int d0, int d1, int d2, int d3)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor4<T> AsReadOnly() => new ReadOnlySpanTensor4<T>(this);
        public SpanTensor4(TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor4(int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor4(Span<T> data, TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor4(Span<T> data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor4(IntPtr data, TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor4(IntPtr data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor4<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize4 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize4 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor3<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor4<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor3<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail3) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor3<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor3<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor4<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor4<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize4(_Dimensions.Head3, lastDim);            

                return new SpanTensor4<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor3<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor3<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor3<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor4<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly unsafe SpanTensor5<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize5(_Dimensions, last);

            return new SpanTensor5<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 5 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor5<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor5<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor5<T> AsReadOnly() => new ReadOnlySpanTensor5<T>(this);
        public SpanTensor5(TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor5(int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor5(Span<T> data, TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor5(Span<T> data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor5(IntPtr data, TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor5(IntPtr data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor5<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize5 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize5 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor4<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor5<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor4<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail4) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor4<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor4<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor5<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor5<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize5(_Dimensions.Head4, lastDim);            

                return new SpanTensor5<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor4<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor4<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor4<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor5<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly unsafe SpanTensor6<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize6(_Dimensions, last);

            return new SpanTensor6<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 6 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor6<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor6<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor6<T> AsReadOnly() => new ReadOnlySpanTensor6<T>(this);
        public SpanTensor6(TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor6(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor6(Span<T> data, TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor6(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor6(IntPtr data, TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor6(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor6<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize6 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize6 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor5<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor6<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor5<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail5) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor5<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor5<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor6<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor6<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize6(_Dimensions.Head5, lastDim);            

                return new SpanTensor6<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor5<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor5<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor5<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor6<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly unsafe SpanTensor7<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize7(_Dimensions, last);

            return new SpanTensor7<TElement>(xdata, xdims);
        }        

        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 7 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor7<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor7<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor7<T> AsReadOnly() => new ReadOnlySpanTensor7<T>(this);
        public SpanTensor7(TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor7(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor7(Span<T> data, TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor7(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor7(IntPtr data, TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor7(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor7<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize7 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize7 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor6<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor7<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor6<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail6) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor6<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor6<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor7<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor7<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize7(_Dimensions.Head6, lastDim);            

                return new SpanTensor7<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor6<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor6<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor6<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor7<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 8 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct SpanTensor8<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public SpanTensor8<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6, d7);
            return this;
        }

        #endregion

        #region lifecycle

        public ReadOnlySpanTensor8<T> AsReadOnly() => new ReadOnlySpanTensor8<T>(this);
        public SpanTensor8(TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor8(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public SpanTensor8(Span<T> data, TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public SpanTensor8(Span<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe SpanTensor8(IntPtr data, TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe SpanTensor8(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new Span<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static SpanTensor8<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize8 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly Span<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize8 Dimensions => _Dimensions;        

        public readonly Span<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public SpanTensor7<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7]        
        {
            
            readonly       
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6, d7)];

            set => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6, d7)] = value;
 
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor8<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor7<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail7) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly SpanTensor7<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new SpanTensor7<T>(data,st.dims);
        }

        public readonly unsafe SpanTensor8<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new SpanTensor8<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize8(_Dimensions.Head7, lastDim);            

                return new SpanTensor8<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe SpanTensor7<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out SpanTensor7<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new SpanTensor7<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor8<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        
        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        
        
        
        public readonly SpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new SpanTensor1<T>(_Buffer, d0);
        }

        public readonly SpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new SpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly SpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new SpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly SpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new SpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly SpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new SpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly SpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new SpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly SpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new SpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly SpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new SpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 1 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor1<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor1<T> VerifyDimensions(int d0)
        {
            
            _Dimensions.VerifyDimensions(d0);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor1<T>(SpanTensor1<T> other) { return new ReadOnlySpanTensor1<T>(other); }

        public ReadOnlySpanTensor1(SpanTensor1<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor1(TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor1(int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor1(ReadOnlySpan<T> data, TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor1(ReadOnlySpan<T> data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor1(IntPtr data, TensorSize1 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor1(IntPtr data, int d0)
        {
            _Dimensions = new TensorSize1(d0);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor1<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize1 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize1 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public T this[int idx]
        {
                  
            get => _Buffer[idx];
                                    
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor1<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

   
        

        
        
        public readonly unsafe ReadOnlySpanTensor2<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize2(_Dimensions, last);

            return new ReadOnlySpanTensor2<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 2 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor2<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor2<T> VerifyDimensions(int d0, int d1)
        {
            
            _Dimensions.VerifyDimensions(d0, d1);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor2<T>(SpanTensor2<T> other) { return new ReadOnlySpanTensor2<T>(other); }

        public ReadOnlySpanTensor2(SpanTensor2<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor2(TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor2(int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor2(ReadOnlySpan<T> data, TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor2(ReadOnlySpan<T> data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor2(IntPtr data, TensorSize2 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor2(IntPtr data, int d0, int d1)
        {
            _Dimensions = new TensorSize2(d0, d1);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor2<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize2 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize2 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor1<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor2<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor1<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail1) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor1<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor1<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor2<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor2<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize2(_Dimensions.Head1, lastDim);            

                return new ReadOnlySpanTensor2<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor1<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor1<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor1<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor2<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor2<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly unsafe ReadOnlySpanTensor3<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize3(_Dimensions, last);

            return new ReadOnlySpanTensor3<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 3 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor3<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor3<T> VerifyDimensions(int d0, int d1, int d2)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor3<T>(SpanTensor3<T> other) { return new ReadOnlySpanTensor3<T>(other); }

        public ReadOnlySpanTensor3(SpanTensor3<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor3(TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor3(int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor3(ReadOnlySpan<T> data, TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor3(ReadOnlySpan<T> data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor3(IntPtr data, TensorSize3 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor3(IntPtr data, int d0, int d1, int d2)
        {
            _Dimensions = new TensorSize3(d0, d1, d2);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor3<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize3 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize3 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor2<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor3<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor2<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail2) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor2<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor2<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor3<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor3<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize3(_Dimensions.Head2, lastDim);            

                return new ReadOnlySpanTensor3<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor2<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor2<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor2<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor3<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor3<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly unsafe ReadOnlySpanTensor4<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize4(_Dimensions, last);

            return new ReadOnlySpanTensor4<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 4 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor4<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor4<T> VerifyDimensions(int d0, int d1, int d2, int d3)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor4<T>(SpanTensor4<T> other) { return new ReadOnlySpanTensor4<T>(other); }

        public ReadOnlySpanTensor4(SpanTensor4<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor4(TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor4(int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor4(ReadOnlySpan<T> data, TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor4(ReadOnlySpan<T> data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor4(IntPtr data, TensorSize4 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor4(IntPtr data, int d0, int d1, int d2, int d3)
        {
            _Dimensions = new TensorSize4(d0, d1, d2, d3);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor4<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize4 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize4 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor3<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor4<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor3<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail3) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor3<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor3<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor4<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor4<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize4(_Dimensions.Head3, lastDim);            

                return new ReadOnlySpanTensor4<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor3<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor3<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor3<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor4<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor4<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly unsafe ReadOnlySpanTensor5<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize5(_Dimensions, last);

            return new ReadOnlySpanTensor5<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 5 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor5<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor5<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor5<T>(SpanTensor5<T> other) { return new ReadOnlySpanTensor5<T>(other); }

        public ReadOnlySpanTensor5(SpanTensor5<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor5(TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor5(int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor5(ReadOnlySpan<T> data, TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor5(ReadOnlySpan<T> data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor5(IntPtr data, TensorSize5 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor5(IntPtr data, int d0, int d1, int d2, int d3, int d4)
        {
            _Dimensions = new TensorSize5(d0, d1, d2, d3, d4);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor5<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize5 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize5 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor4<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor5<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor4<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail4) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor4<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor4<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor5<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor5<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize5(_Dimensions.Head4, lastDim);            

                return new ReadOnlySpanTensor5<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor4<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor4<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor4<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor5<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor5<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly unsafe ReadOnlySpanTensor6<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize6(_Dimensions, last);

            return new ReadOnlySpanTensor6<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 6 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor6<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor6<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor6<T>(SpanTensor6<T> other) { return new ReadOnlySpanTensor6<T>(other); }

        public ReadOnlySpanTensor6(SpanTensor6<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor6(TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor6(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor6(ReadOnlySpan<T> data, TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor6(ReadOnlySpan<T> data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor6(IntPtr data, TensorSize6 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor6(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5)
        {
            _Dimensions = new TensorSize6(d0, d1, d2, d3, d4, d5);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor6<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize6 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize6 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor5<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor6<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor5<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail5) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor5<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor5<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor6<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor6<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize6(_Dimensions.Head5, lastDim);            

                return new ReadOnlySpanTensor6<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor5<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor5<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor5<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor6<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor6<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly unsafe ReadOnlySpanTensor7<TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);
            var xdims = new TensorSize7(_Dimensions, last);

            return new ReadOnlySpanTensor7<TElement>(xdata, xdims);
        }        

        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 7 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor7<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor7<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor7<T>(SpanTensor7<T> other) { return new ReadOnlySpanTensor7<T>(other); }

        public ReadOnlySpanTensor7(SpanTensor7<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor7(TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor7(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor7(ReadOnlySpan<T> data, TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor7(ReadOnlySpan<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor7(IntPtr data, TensorSize7 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor7(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            _Dimensions = new TensorSize7(d0, d1, d2, d3, d4, d5, d6);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor7<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize7 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize7 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor6<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor7<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor6<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail6) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor6<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor6<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor7<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor7<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize7(_Dimensions.Head6, lastDim);            

                return new ReadOnlySpanTensor7<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor6<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor6<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor6<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor7<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor7<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
    /// <summary>
    /// Represents a dense tensor of 8 dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct ReadOnlySpanTensor8<T>
    where T : unmanaged
    {
        #region diagnostics

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public ReadOnlySpanTensor8<T> VerifyDimensions(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            
            _Dimensions.VerifyDimensions(d0, d1, d2, d3, d4, d5, d6, d7);
            return this;
        }

        #endregion

        #region lifecycle

        public static implicit operator ReadOnlySpanTensor8<T>(SpanTensor8<T> other) { return new ReadOnlySpanTensor8<T>(other); }

        public ReadOnlySpanTensor8(SpanTensor8<T> other)
        {
            _Dimensions = other._Dimensions;
            _Buffer = other._Buffer;
        }

        public ReadOnlySpanTensor8(TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor8(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new T[_Dimensions.StepSize];
        }

        public ReadOnlySpanTensor8(ReadOnlySpan<T> data, TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public ReadOnlySpanTensor8(ReadOnlySpan<T> data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = data.Slice(0, _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor8(IntPtr data, TensorSize8 dims)
        {
            _Dimensions = dims;
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        public unsafe ReadOnlySpanTensor8(IntPtr data, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            _Dimensions = new TensorSize8(d0, d1, d2, d3, d4, d5, d6, d7);
            _Buffer = new ReadOnlySpan<T>(data.ToPointer(), _Dimensions.StepSize);
        }

        #if NET8_0_OR_GREATER
        #pragma warning disable SYSLIB5001
        public static ReadOnlySpanTensor8<T> From(System.Numerics.Tensors.TensorSpan<T> other)
        {
            throw new NotImplementedException();
        }

        #pragma warning disable SYSLIB5001
        #endif
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly TensorSize8 _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly ReadOnlySpan<T> _Buffer;        

        #endregion

        #region properties
        public readonly TensorSize8 Dimensions => _Dimensions;        

        public readonly ReadOnlySpan<T> Span => _Buffer;

        public uint GetChecksum()
        {
            var crc = Crc32.Create();
            crc.AppendChecksum(this.Dimensions);
            crc.AppendChecksum(_Buffer);
            return crc.Value;
        }

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        
        public ReadOnlySpanTensor7<T> this[int idx] => GetSubTensor(idx);

        public T this[int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7]        
        {
            
                  
            get => _Buffer[_Dimensions.GetFlattenedIndex(d0, d1, d2, d3, d4, d5, d6, d7)];

             
        }

        
        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }

        public readonly void CopyTo<TOther>(SpanTensor8<TOther> dst) where TOther:unmanaged
        {
            if (this.Dimensions != dst.Dimensions) throw new ArgumentException("Dimensions mismatch",nameof(dst));
            var result = _ArrayUtilities.TryConvertSpan<T,TOther>(this.Span, dst.Span);
            if (!result) throw new ArgumentException("type conversion not supported",nameof(dst));
        }

        public readonly void CopyTo(SpanTensor7<T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail7) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

   
        

        

        

        public readonly ReadOnlySpanTensor7<T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new ReadOnlySpanTensor7<T>(data,st.dims);
        }

        public readonly unsafe ReadOnlySpanTensor8<TElement> Cast<TElement>()
            where TElement:unmanaged        
        {
            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            if (typeof(T) == typeof(TElement))
            {
                return new ReadOnlySpanTensor8<TElement>(xdata, _Dimensions);
            }
            else
            {
                var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);            
            
                var xdims = new TensorSize8(_Dimensions.Head7, lastDim);            

                return new ReadOnlySpanTensor8<TElement>(xdata, xdims);
            }
        }

        public readonly unsafe ReadOnlySpanTensor7<TElement> UpCast<TElement>()
            where TElement:unmanaged        
        {
            return TryUpCast<TElement>(out var result)
                ? result
                : throw new ArgumentException(nameof(TElement));
        }

        public readonly unsafe bool TryUpCast<TElement>(out ReadOnlySpanTensor7<TElement> result)
            where TElement:unmanaged
        {
            result = default;
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) return false;

            var xdata = MEMORYMARSHALL.Cast<T,TElement>(_Buffer);

            result = new ReadOnlySpanTensor7<TElement>(xdata, _Dimensions.GetTensorHead());
            return true;
        }

        public readonly void CopyTransposed(SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref SpanTensor8<T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new SpanTensor8<T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        /*

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        */

        
        
        public readonly ReadOnlySpanTensor1<T> Reshaped(int d0)
        {
            if (_Buffer.Length != (d0)) throw new ArgumentException();
            return new ReadOnlySpanTensor1<T>(_Buffer, d0);
        }

        public readonly ReadOnlySpanTensor2<T> Reshaped(int d0, int d1)
        {
            if (_Buffer.Length != (d0 * d1)) throw new ArgumentException();
            return new ReadOnlySpanTensor2<T>(_Buffer, d0, d1);
        }

        public readonly ReadOnlySpanTensor3<T> Reshaped(int d0, int d1, int d2)
        {
            if (_Buffer.Length != (d0 * d1 * d2)) throw new ArgumentException();
            return new ReadOnlySpanTensor3<T>(_Buffer, d0, d1, d2);
        }

        public readonly ReadOnlySpanTensor4<T> Reshaped(int d0, int d1, int d2, int d3)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3)) throw new ArgumentException();
            return new ReadOnlySpanTensor4<T>(_Buffer, d0, d1, d2, d3);
        }

        public readonly ReadOnlySpanTensor5<T> Reshaped(int d0, int d1, int d2, int d3, int d4)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4)) throw new ArgumentException();
            return new ReadOnlySpanTensor5<T>(_Buffer, d0, d1, d2, d3, d4);
        }

        public readonly ReadOnlySpanTensor6<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5)) throw new ArgumentException();
            return new ReadOnlySpanTensor6<T>(_Buffer, d0, d1, d2, d3, d4, d5);
        }

        public readonly ReadOnlySpanTensor7<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6)) throw new ArgumentException();
            return new ReadOnlySpanTensor7<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6);
        }

        public readonly ReadOnlySpanTensor8<T> Reshaped(int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7)
        {
            if (_Buffer.Length != (d0 * d1 * d2 * d3 * d4 * d5 * d6 * d7)) throw new ArgumentException();
            return new ReadOnlySpanTensor8<T>(_Buffer, d0, d1, d2, d3, d4, d5, d6, d7);
        }

      
        

        #endregion
    }

    
}
