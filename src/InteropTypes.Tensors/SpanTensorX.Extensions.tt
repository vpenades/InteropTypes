<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated />
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Numerics.Tensors;
using System.Text;

namespace InteropTypes.Tensors
{
    public static partial class SpanTensor
    {
        <#
    
        var TDIM_MAX = 8;

        for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT) {

        var TARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"int d{idx}"));
        var TNEWSIZE = $"new TensorSize{TDIMCOUNT}(" + String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")) + ")";

        #>

        public static void ApplySoftMax(this SpanTensor<#= TDIMCOUNT#><float> tensor)
        {
            SpanTensor.ApplySoftMax(tensor.Span);
        }

        <# if (TDIMCOUNT == 1) { #>

        public static int IndexOf<T>(this SpanTensor1<T> tensor, T value)
        where T : unmanaged, IEquatable<T>
        {
            return tensor._Buffer.IndexOf(value);
        }

        public static int IndexOf<T>(this SpanTensor1<T> tensor, Predicate<T> predicate)
        where T : unmanaged, IEquatable<T>
        {
            var span = tensor._Buffer;
            for (int i = 0; i < span.Length; ++i)
            {
                if (predicate(span[i])) return i;
            }

            return -1;
        }

        public static int IndexOfMax<T>(this SpanTensor1<T> tensor, IComparer<T> comparer = null)
        where T : unmanaged
        {
            var span = tensor._Buffer;

            if (span.IsEmpty) return -1;

            if (comparer == null) comparer = Comparer<T>.Default;

            T max = span[0];
            var idx = 0;

            for (int i = 1; i < span.Length; ++i)
            {
                var item = span[i];
                if (comparer.Compare(max, item) > 0) { max = item; idx = i; }
            }

            return idx;
        }

        <# } else { #>
        
        public static TensorIndices<#= TDIMCOUNT#> IndexOf<T>(this SpanTensor<#= TDIMCOUNT#><T> tensor, T value)
        where T : unmanaged, IEquatable<T>
        {
            var idx = tensor._Buffer.IndexOf(value);
            if (idx < 0) return TensorSize<#= TDIMCOUNT#>.Invalid;
            return tensor._Dimensions.GetDecomposedIndex(idx);
        }

        
        public static TensorIndices<#= TDIMCOUNT#> IndexOf<T>(this SpanTensor<#= TDIMCOUNT#><T> tensor, Predicate<T> predicate)
        where T : unmanaged, IEquatable<T>
        {
            var span = tensor._Buffer;

            for (int i = 0; i < span.Length; ++i)
            {
                if (predicate(span[i])) return tensor._Dimensions.GetDecomposedIndex(i);
            }

            return TensorIndices<#= TDIMCOUNT#>.Invalid;
        }

        
        public static TensorIndices<#= TDIMCOUNT#> IndexOfMax<T>(this SpanTensor<#= TDIMCOUNT#><T> tensor, IComparer<T> comparer = null)
        where T : unmanaged
        {
            var span = tensor._Buffer;            

            if (typeof(T) == typeof(float))
            {
                var floats = System.Runtime.InteropServices.MemoryMarshal.Cast<T,float>(span);
                var fidx = System.Numerics.Tensors.TensorPrimitives.IndexOfMax(floats);
                return fidx < 0 ? TensorIndices<#= TDIMCOUNT#>.Invalid : tensor._Dimensions.GetDecomposedIndex(fidx);
            }

            if (span.IsEmpty) return TensorIndices<#= TDIMCOUNT#>.Invalid;

            if (comparer == null) comparer = Comparer<T>.Default;

            T max = span[0];
            var idx = 0;

            for (int i = 1; i < span.Length; ++i)
            {
                var item = span[i];
                if (comparer.Compare(max , item) >  0) { max = item; idx = i; }
            }

            return tensor._Dimensions.GetDecomposedIndex(idx);
        }        

        <# } #>        

    <# } #>

    }
}
