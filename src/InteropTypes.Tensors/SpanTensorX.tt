<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="SpanTensorCodeGen.t4" #>
// <auto-generated />
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.Numerics.Tensors;
using System.Text;

namespace InteropTypes.Tensors
{
    <#
    
    var TDIM_MAX = 8;

    for(var __isReadOnly = 0; __isReadOnly <= 1; ++__isReadOnly)    
    {
    
    for(var TDIMCOUNT = 1; TDIMCOUNT <= TDIM_MAX; ++TDIMCOUNT)    
    {
        var context = new SpanTensorCodeGen(_WriteLines, TDIMCOUNT, __isReadOnly == 1);

        var TARGS = context.Arguments; 
        var TNEWSIZE = context.NewTensorSize;

        var CLASSNAME = context.ClassName;
        var CLASSNAMEMINUSONE = context.ClassNameMinusOne;
        var CLASSNAMEPLUSONE = context.ClassNamePlusOne;

        var TENSORSIZENAME = $"TensorSize{TDIMCOUNT}";
        var TENSORSIZENAMEPLUSONE = $"TensorSize{TDIMCOUNT+1}";

        var SPANTYPE = context.SpanTypeName;

        ClearIndent();        
     
     #>

    /// <summary>
    /// Represents a dense tensor of <#= TDIMCOUNT#> dimensions.
    /// </summary>
    [System.Diagnostics.DebuggerDisplay("{_GetDebuggerDisplayString(),nq}")]
    public readonly ref partial struct <#= CLASSNAME#><T>
    where T : unmanaged
    {
        #region debug

        private string _GetDebuggerDisplayString()
        {
            var text = "Tensor " + string.Join("×", _Dimensions) + "×" + typeof(T).Name;

            var (min, max) = _Buffer.GetMinMax();

            text += $" [{min} < {max}]";

            return text;
        }        

        public <#=CLASSNAME#><T> VerifyDimensions(<#= TARGS#>)
        {
            <# var TVERIFYARGS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")); #>

            _Dimensions.VerifyDimensions(<#= TVERIFYARGS#>);
            return this;
        }

        #endregion

        #region lifecycle

        <# 

        ClearIndent();
        PushIndent("        ");
        _WriteLines(context.WriteContructors());
        PopIndent();

        #>
        #endregion

        #region data        

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly <#= TENSORSIZENAME#> _Dimensions;

        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal readonly <#=SPANTYPE#> _Buffer;        

        #endregion

        #region properties
        public readonly <#= TENSORSIZENAME#> Dimensions => _Dimensions;        

        public readonly <#=SPANTYPE#> Span => _Buffer;

        public readonly T[] ToArray() { return _Buffer.ToArray(); }
        
        <# if (TDIMCOUNT > 1) { #>

        public <#= CLASSNAMEMINUSONE#><T> this[int idx] => GetSubTensor(idx);

        public T this[<#= TARGS#>]        
        {
            <# var TARGVARS = String.Join(", ",Enumerable.Range(0,TDIMCOUNT).Select(idx => $"d{idx}")); #>

            <# if (!context.IsReadOnly) Write("readonly "); #>      
            get => _Buffer[_Dimensions.GetFlattenedIndex(<#= TARGVARS#>)];

            <# if (!context.IsReadOnly) WriteLine($"set => _Buffer[_Dimensions.GetFlattenedIndex({TARGVARS})] = value;"); #> 
        }

        <# } else { #>

        public T this[int idx]
        {
            <# if (!context.IsReadOnly) Write("readonly "); #>      
            get => _Buffer[idx];
            <# if (!context.IsReadOnly) WriteLine("set => _Buffer[idx] = value;"); #>                        
        }

        <# } #>

        public readonly Statistics Statistics => Statistics.Create<T>(this.Span);

        #endregion

        #region API

        public readonly void CopyTo(Span<T> dst)
        {
            this._Buffer.CopyTo(dst);
        }      
        

        <# if (TDIMCOUNT > 1) { #>

        public readonly void CopyTo(<#=context.WriteableClassNameMinusOne#><T> dst, int tailIdx)
        {
            if (dst._Dimensions != this._Dimensions.Tail<#= TDIMCOUNT-1#>) throw new ArgumentException(nameof(dst));

            var step = this._Dimensions.Last;
            var len = this._Buffer.Length / step;

            for (int i=0; i < len; ++i) dst._Buffer[i] = this._Buffer[i * step + tailIdx];
        }

        public readonly <#= CLASSNAMEMINUSONE#><T> GetSubTensor(int idx)
        {
            if (idx < 0 || idx >= _Dimensions.Dim0) throw new IndexOutOfRangeException(nameof(idx));

            var st = _Dimensions.GetTensorTail(idx);
            
            var data = _Buffer.Slice(st.offs, st.dims.StepSize);

            return new <#= CLASSNAMEMINUSONE#><T>(data,st.dims);
        }

        public readonly unsafe <#= CLASSNAME#><TElement> Cast<TElement>()
            where TElement:unmanaged
        {
            var lastDim = _Dimensions.Last * sizeof(T) / sizeof(TElement);

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            
            var xdims = new <#= TENSORSIZENAME#>(_Dimensions.Head<#= TDIMCOUNT-1#>, lastDim);            

            return new <#= CLASSNAME#><TElement>(xdata, xdims);
        }

        public readonly unsafe <#= CLASSNAMEMINUSONE#><TElement> UpCast<TElement>()
            where TElement:unmanaged
        {
            if (sizeof(T) * _Dimensions.Last != sizeof(TElement)) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);

            return new <#= CLASSNAMEMINUSONE#><TElement>(xdata, _Dimensions.GetTensorHead());
        }

        public readonly void CopyTransposed(<#=context.WriteableClassName#><T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));            
            if (dst.Dimensions != this.Dimensions) throw new ArgumentException($"dimensions mismatch.", nameof(dst));            

            // TODO: if memory overlaps, we can use a swap strategy, instead of a copy strategy

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }
        }
        
        public readonly bool CopyTransposed(ref <#=context.WriteableClassName#><T> dst, params int[] indices)
        {
            var size = this.Dimensions[0];

            if (indices.Length != size) throw new ArgumentException($"must have {size} arguments.", nameof(indices));

            var updated = false;

            if (dst.Dimensions != this.Dimensions)
            {
                dst = new <#=context.WriteableClassName#><T>(this.Dimensions);
                updated = true;
            }

            if (this.Span.Overlaps(dst.Span)) throw new ArgumentException("Memory overlaps", nameof(dst));

            for(int i=0; i < size; ++i)
            {
                var srcSpan = this[i].Span;
                var dstSpan = dst[indices[i]].Span;
                
                srcSpan.CopyTo(dstSpan);            
            }

            return updated;
        }

        <# if (context.IsReadOnly) WriteLine("/*"); #>

        public void ApplySwap(int index0, int index1)
        {
            var span0 = this[index0].Span;
            var span1 = this[index1].Span;            

            for(int i=0; i < span0.Length; ++i)
            {
                var tmp = span0[i];
                span0[i] = span1[i];
                span1[i] = tmp;
            }
        }

        <# if (context.IsReadOnly) WriteLine("*/"); #>

        <# } #>

        <# if (TDIMCOUNT < TDIM_MAX-1) { #>

        public readonly unsafe <#= CLASSNAMEPLUSONE#><TElement> DownCast<TElement>()
            where TElement:unmanaged
        {
            var thisSize = sizeof(T);
            var otherSize = sizeof(TElement);

            if (otherSize > thisSize) throw new ArgumentException(nameof(TElement));            

            int last = thisSize / otherSize;

            if (last * otherSize != thisSize) throw new ArgumentException(nameof(TElement));

            var xdata = System.Runtime.InteropServices.MemoryMarshal.Cast<T,TElement>(_Buffer);
            var xdims = new <#= TENSORSIZENAMEPLUSONE#>(_Dimensions, last);

            return new <#= CLASSNAMEPLUSONE#><TElement>(xdata, xdims);
        }        

        <# } #>

        <#

        for(var TDIMCOUNT2 = 1; TDIMCOUNT2 <= TDIM_MAX; ++TDIMCOUNT2)
        {
            var context2 = new SpanTensorCodeGen(_WriteLines, TDIMCOUNT2, __isReadOnly == 1);

            var lines= context2.WriteReshapedMethod();

            ClearIndent();
            PushIndent("        ");
            _WriteLines(lines);
            PopIndent();
        }
            
        #>      
        

        #endregion
    }

    <#
    
    }
    
    }
    
    void _WriteLines(IEnumerable<string> lines)
    {
        foreach(var line in lines)
        {
            if (line == "{") { PushBrackets(); continue; }
            if (line == "}") { PopBrackets(); continue; }
            WriteLine(line);        
        }    
    }

    void PushBrackets() { WriteLine("{"); PushIndent("    "); }
    void PopBrackets() { PopIndent(); WriteLine("}"); WriteLine(""); }
    
    #>

}
